
# Day-1 : Fundamentals of R Programming 

## Learning Objectives

By the end of this day, students will be able to:

- Understand what R is and where it is used
- Use R as a calculator (basic operations)
- Create and manipulate basic R objects
- Work with core R data structures (vectors, lists, data frames)
- Understand basic program control using conditions and loops

## What Is R?

R is an interpreted language, where code is executed interactively and results are shown immediately.

Interactively means:

1. You type a command
2. R executes it right away
3. You immediately see the output or error
4. Then you decide what to do next

This interpreted behavior of R is very important for task like data Analysis and modeling.

R is a **programming language and environment** designed for:

- Statistical analysis
- Data visualization
- Reproducible research

R is widely used in academia, research:

- Statistics
- Epidemiology
- Genomics
- Social sciences
- Machine learning research


One of Râ€™s biggest strengths is its **ecosystem of packages**, including  **CRAN** and **Bioconductor**.

---

## RStudio Interface (Quick Tour)

RStudio provides a user-friendly interface for working with R.

Main components:
- **Console** â€“ where commands are executed
- **Script Editor** â€“ where you write and save code
- **Environment** â€“ shows created objects
- **Plots / Files / Help** â€“ outputs and documentation

> ðŸ’¡ Tip:  
> Always write code in a **script file**, not directly in the Console.

---

## Creating Objects in R

In R, everything you work with is stored in an object. It has five basic classes of object: character, numeric, integer, complex and logical.(also data types in R)

An object can be thought of as a container that has:

- a structure, defined by its data structure (e.g., vector, list, data frame), and
- values, whose nature is defined by data types (e.g., numeric, character, logical).

Objects allow you to store, reuse, and manipulate data throughout your analysis.

Assignment is typically done using <-:

```{r}

x <- 10
y <- 3

z = 10

10 -> a
20 -> b

```

Use the objects in calculations:

```{r}

x + y
x * y

```

## Attributes 

In layman term you can think of them as properties of an object.

- names: labels for elements
- dim: dimensions of an object (rows and columns)
- dimnames: names for rows and columns
- class: defines the objectâ€™s behavior
- length: number of elements
- User-defined attributes:  metadata

```{r}

x <- c(10, 20, 30) # function c is used to create a vector
names(x) <- c("a", "b", "c")

attributes(x)

m <- matrix(1:6, nrow = 2)
dimnames(m) <- list(
  c("Row1", "Row2"),
  c("Col1", "Col2", "Col3")
)
m
attributes(m)

df <- data.frame(id = 1:3, score = c(80, 90, 85))
class(df)
dim(df)
names(df)

# user define attributes
x <- c(5, 10, 15)

attr(x, "source") <- "Survey Data"
attr(x, "collected_on") <- "2026-01-22"

attributes(x)

attr(x, "source") <- NULL

```


---

## Using R as a Calculator

Letâ€™s start with simple arithmetic and basic mathematical **operations** 

Summary: Common R Operators

| Category            | Operator | Description                  | Example        |
|---------------------|----------|------------------------------|----------------|
| Arithmetic          | `+`      | Addition                     | `2 + 3`        |
| Arithmetic          | `-`      | Subtraction                  | `5 - 2`        |
| Arithmetic          | `*`      | Multiplication               | `4 * 3`        |
| Arithmetic          | `/`      | Division                     | `8 / 2`        |
| Arithmetic          | `^`      | Exponentiation               | `2^3`          |
| Arithmetic          | `%%`     | Remainder (modulus)          | `10 %% 3`      |
| Arithmetic          | `%/%`    | Integer division             | `10 %/% 3`     |
| Comparison          | `==`     | Equal to                     | `x == 5`       |
| Comparison          | `!=`     | Not equal to                 | `x != 3`       |
| Comparison          | `>`      | Greater than                 | `x > 5`        |
| Comparison          | `<`      | Less than                    | `x < 2`        |
| Logical             | `&`      | AND                          | `x > 1 & x <5` | 
| Logical             | `|`      | OR                           | `x < 2 | x >8` |
| Assignment          | `<-`     | Assign value                 | `x <- 10`      |


```{r}

2 + 3 # addition 
10 - 4 # sub
5 * 6 # multiply
8 / 2 # divide

```


```{r}

2 + 3 * 4      # multiplication first
(2 + 3) * 4    # parentheses change order

```

Additional useful operators:

```{r}

2^3 # Exponentiation
10 %% 4 # Remainder # (10 %% 3)
10 %/% 3 # Integer division

```

## Comments

Comments in R:

Purpose: To explain code, add notes, or temporarily disable code.
Syntax: Start with a hash symbol (#).
Behavior: Ignored during execution; have no functional impact. 

```{r}
# This is a comment
x <- 10   # Assign 10 to x
y <- 5    # Assign 5 to y

x + y     # Add x and y

# Even if a comment appears after code, it is still ignored:

x <- 10
# x <- 100   # This line will not be executed
x
  
```

### Documentation comments using #'

The #' syntax is a special type of comment used for documentation, mainly when writing functions or packages.

```{r}
#' Add two numbers
#'
#' This function takes two numeric values and returns their sum.
#' 


add_numbers <- function(a, b) {
  a + b
}

add_numbers(2,3)

```

---

## Basic Data Types

In programming, data type is an important concept.
Variables can store data of different types, and different types can do different things.

Common data types in R include:

### Summary: Basic R Data Types

| Data Type   | Description                         | Example                  |
|-------------|-------------------------------------|--------------------------|
| numeric     | Decimal numbers                     | `3.14`, `10.5`           |
| integer     | Whole numbers                       | `10L`, `5L`              |
| character   | Text strings                        | `"genomics"`             |
| logical     | Boolean values                      | `TRUE`, `FALSE`          |
| complex     | Complex numbers                     | `2 + 3i`                 |


```{r}

numeric_value <- 3.14 # (10.5, 55, 787)

integer_value <- 10L # (1L, 55L, 100L, where the letter "L" declares this as an integer)

character_value <- "genomics" # ("k", "R is exciting", "FALSE", "11.5")

logical_value <- TRUE # (a.k.a. boolean) - (TRUE or FALSE)

complex_value <- c(9 + 3i) # where "i" is the imaginary part

#### special numeric values
Inf # 1/0
NaN # not a number (also treated as missing values)
0/0

```

Check the type of an object:

```{r}

class(numeric_value)
class(character_value)
class(logical_value)

```

Type Conversion

- You can convert from one type to another with the following functions:

as.numeric()
as.integer()
as.complex()

```{r}

x <- 5L # integer
y <- 7 # numeric

# convert from integer to numeric:
a <- as.numeric(x)

# convert from numeric to integer:
b <- as.integer(y)

# print values of x and y
class(x)
class(y)

# print the class name of a and b
class(a)
class(b)

# problem with some conversion
x <- c("a", "b", "c")

as.numeric(x)
as.logical(x)

# what is the hack here?
as.numeric(as.factor(x))

```

---

## Data Structures

Data structures are used to store and organize data values/ types.

### Summary: Core R Data Structures

| Structure    | Description                                  | Example                                  
|--------------|----------------------------------------------|------------------------------------------
| Vector       | Same data type, 1D                           | `c(1, 2, 3)`                            
| List         | Different data types allowed                 | `list(1, "A", TRUE)`                   
| Factor       | Categorical data with levels                 | `factor(c("A","B"))`                    
| Data Frame   | Tabular data, columns of equal length        | `data.frame(x=1:3, y=c("A","B","C"))`   
| Matrix       | Same data type, 2D                           | `matrix(1:6, nrow=2)`                  
| Array        | Same data type, multi-dimensional            | `array(1:8, dim=c(2,2,2))`             


R provides many built-in data structures. Each is used to handle data in different ways:

### Vector

A vector is the most basic data structure in R. It contains a list of items of the same type.


```{r}

numbers <- c(1, 2, 3, 4, 5)
genes <- c("TP53", "BRCA1", "EGFR")
flags <- c(TRUE, FALSE, TRUE)

# using vector function

vector("numeric", length = 10) # created empty vector


```

What if we mix the data types.

```{r}
y <- c(1.7, "a")
y # character

y <- c(TRUE, 2)
y # numeric

# this is called Coercion
# every element of vector needs to be of same type

# explicitly coercion: we will see in type conversion

```


Indexing vectors:

```{r}

numbers[1]
numbers[2:4]
genes[2]

numbers[-2] # excess all elements except 2nd 
numbers[-1:-4] # excess only 5th element 

```

### Lists

- A list is a flexible data structure in R that can store different types of objects together.

- Unlike vectors, list elements do not have to be the same data type.

- Creating a List

```{r}

my_list <- list(
numbers = c(1, 2, 3),
gene = "TP53",
flag = TRUE,
data = data.frame(id = 1:3, value = c(10, 20, 30))
)

my_list

```

Accessing List Elements

```{r}

my_list$numbers
my_list[[2]]
my_list[1]


my_list[["flag"]]

```

$ â†’ access by name

[[]] â†’ extract one element

[ ] â†’ returns a sub-list

- Why Lists Are Important
- Many R functions return results as lists.


```{r}

model <- lm(mpg ~ wt, data = mtcars)
model

model$coefficients
model$model
model$fitted.values

```


```{r}

numbers * 2
numbers + 10

```

### Matrices

Matrices are special kind of vector which has dimension attribute. It has rows and columns 

```{r}

# it is constructed as column first
m <- matrix(1:8)
dim(m)
attributes(m)

m <- matrix(1:8, nrow = 3, ncol = 3)
dim(m)
attributes(m)

# matrices can be created from vectors by adding dimension attribute

m <- 1:9
dim(m) <- c(3, 3)
m

# matrices can be create by cbind and rbind
y <- 1:3
z <- 10:12

cbind(y, z)
rbind(y, z)

```

### Factors

Factors are used to represent **categorical data** in R. It can be ordered or unordered. you can think of factors as integer with each integer value maps to **label**.

factors are really important when you will proceed to statistical test or models. Because the first label is treated as baseline label.

its good to have factors with labels as compare to integers, eg. male or female rather than 1 or 2.


```{r}

group <- factor(c("A", "B", "A", "B"))
group
levels(group)

table(group)

unclass(group)

as.numeric(group) # this show how they are stored internally

group <- factor(
  c("A", "B", "A", "B"),
  levels = c("A", "B"), # levels use to set order 
  labels = c("Control", "Treatment")
)

group

```

### Missing values

Missing values are donated by NA or NaN. 
use is.na () to detect NA and is.nan() for NaN.
These can character or numeric etc.
A NaN values is also NA, but converse is not true.


```{r}
x <- c(1, 2, NA, 4, 5)
is.na(x)
is.nan(x)

x <- c(1, 2, NA, NaN, 5)
is.na(x)
is.nan(x)

# subsetting or removing missing values

# very common task in analysis
x <- c(1, 2, NA, 4, 5)

x[!is.na(x)]

x[complete.cases(x)]

na.omit(x)

data(airquality)

dim(airquality)

dim(airquality[complete.cases(airquality), ])

dim(na.omit(airquality))

```


### Data Frames

A data frame is a table-like structure where each column can be a different data type.
Mostly well suited for tabular data as in our csv or excel files. read.csv() and read.table() ara base functions to read these files 
special type of list, where every list needs to be of same length.


```{r}

df <- data.frame(
id = 1:5,
age = c(23, 35, 41, 29, 50),
group = c("A", "B", "A", "B", "A")
)

df

```

Inspecting a data frame:

```{r}
dim(df)
str(df)
summary(df)
head(df)

```

Accessing columns:

```{r}

df$age
df[, "group"]

df[1, ]
df[10, ]
df[, 2]
df[, 3]

```

## Vectorization: Thinking in Vectors

One of the key ideas in R is **vectorization**.

In R, most operations are designed to work on **entire vectors at once**, rather than
one element at a time. This makes R code:

- Simpler to write
- Easier to read
- Faster to execute

This is different from many other programming languages, where you often need loops to process each value individually.

```{r}
x <- c(1, 2, 3, 4, 5); y <- c(6, 7, 8, 9, 10) # element wise addition

x+y

x > 3


# vectorization
x * 2
# using loop
result <- numeric(length(x))
for (i in seq_along(x)) {
  result[i] <- x[i] * 2
}


```


## Working with Text (Strings)

In R, text data is stored as character vectors.
A single string is a character vector of length 1, and individual characters are accessed only after explicitly splitting the string.


```{r}
gene_string <- "ATGCGATAGCGAG"
gene_string

```

Splitting a String into Characters

To work with individual letters, the string must be split into a character vector.

```{r}

chars <- strsplit(gene_string, "")[[1]]
chars
length(chars)

# strsplit() returns a list
# 
# [[1]] extracts the character vector


# Looping Through Characters

for (char in chars) {
  print(char)
}


```


Count the number of characters in a string:

nchar() counts characters, not vector length.

```{r}

nchar(gene_string)

```

Counting Specific Characters

Finding the First Position of a Pattern: regexpr()

```{r}

regexpr("AG", gene_string)[1]

# regexpr() finds the first occurrence of a pattern
# The result gives the starting position and match length
```

Finding All Positions of a Pattern: gregexpr()

```{r}

gregexpr("AG", gene_string)[[1]]

# gregexpr() finds all occurrences
# Returns a list of positions

```

Find number of occurrence of particular character

```{r}

table(chars)

sum(chars == "A")
sum(chars == "G")

sum(strsplit(gene_string, "")[[1]] == "A")
sum(strsplit(gene_string, "")[[1]] == "G")

```

Pattern Matching
Check if a pattern exists:

```{r}

grepl("CG", gene_string)

# Returns TRUE or FALSE
```

Count how many times a pattern occurs:

```{r}

length(gregexpr("CG", gene_string)[[1]])

# gregexpr() returns match positions
# length() gives the number of matches

```

Additional Useful Base R String Functions

Convert Case:

```{r}
tolower(gene_string)
toupper(gene_string)

```

Extract Substrings from particular postion

```{r}
substr(gene_string, start = 1, stop = 3)

```

Replace Text where ever the string matches

```{r}
sub("CG", "XX", gene_string)
# Replaces the first occurrence of a pattern.

gsub("CG", "XX", gene_string)
# gsub() replaces all occurrences
```

## Control Structures

Control structures allow R to make decisions and repeat actions based on conditions.
They are used when the flow of execution needs to change depending on the data or logic.

Conditional Statements: if and else

Conditional statements execute different code blocks depending on whether a condition is TRUE or FALSE.

```{r}

x <- 3

if (x > 5) {
  "x is greater than 5"
} else {
  "x is less than or equal to 5"
}

# if checks a condition
# else runs when the condition is not met

```

Vectorized Conditionals: ifelse()

ifelse() applies a condition element-wise to vectors, making it useful for data analysis.


```{r}
x <- c(3, 7, 2, 9)

ifelse(x > 5, "High", "Low")

# Works on entire vectors at once
# Commonly used for creating new columns or labels

```


for Loop

A for loop repeats a block of code for each value in a sequence.


```{r}

for (i in 1:5) {
  print(i)
}

# Useful when an operation must be repeated step-by-step
# In R, vectorized solutions are often preferred when possible

```

while Loop

A while loop keeps running as long as a condition remains TRUE.

```{r}

x <- 1

while (x <= 5) {
  print(x)
  x <- x + 1
}

# The condition is checked before each iteration
# Be careful to update the condition to avoid infinite loops

```

Infinite Loop (Conceptual Example)

An infinite loop occurs when a loop condition never becomes FALSE.
This can cause the program to run forever unless explicitly stopped.

```{r}

# while (TRUE) {
# print("This will run forever")
# }

# Infinite loops usually happen due to missing or incorrect stopping conditions.

```

### Loop Control: break and next

Using **break** to Stop a Loop Early.

break exits a loop before it finishes all iterations.

```{r}

for (i in 1:10) {
    
    if (i == 5) {
        break
    }
    
    print(i)
}

```

Explanation:

 - The loop stops as soon as i becomes 5

 - Remaining values are not processed

Use case:

- Stop processing when a condition of interest is reached.

Using **next** to Skip an Iteration

next skips the current iteration and continues with the next one.

```{r}

for (i in 1:5) {

if (i == 3) {
next
}

print(i)
}

# explanation:
# 
# The value 3 is skipped
# 
# All other values are processed normally
# 
# Use case:
# 
# Ignore missing, invalid, or unwanted values.

```

## functions

Functions are created using function() directive and stored as object. In particular, they are R object of class function. 

Functions can be passed as arguments to another function. 
functions can be nested so that you can define one function inside of other.

```{r}

class(mean)

f <- function(arguments) {
  # code to perform a task
}
```

Function Arguments:

Arguments are the inputs to a function.
They allow functions to work with different values without rewriting code.

```{r}
square <- function(x) {
  x^2
}

square(5)
square(c(1, 2, 3))

# multiple arguments
add_numbers <- function(a, b) {
  a + b
}

# Arguments can be passed:
# By position
# By name

add_numbers(2, 3)
add_numbers(b = 3, a = 2)

# Default Argument Values
# Arguments can have default values, making them optional.

power <- function(x, exponent = 2) {
  x^exponent
}

power(4)       # uses default exponent
power(4, 3)    # overrides default

# Named vs Positional Arguments (Important)
seq(from = 1, to = 10, by = 2)
seq(1, 10, 2)

# Named arguments improve readability and reduce errors. it is recommended to not to mess with default order, might lead to confusion. start with reading the function using ?.

mydata <- rnorm(100)

sd(mydata)
sd(x = mydata)

sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)

# it is also possible to not define default value of argument

f <- function(a,b=2,c=4, d=NULL) {
  a^2
}

# lazy evaluation: arguments are evaluated lazily, that mean they are evaluated only if they needed.

f(4) # did not use any other argument except a, and didn't produce any error.

# fname <- function(a, b) {
#   print(a)
#   print(b)
# }
# fname(3) # here function will evaluate b also

```

The ... (Dot-Dot-Dot) Argument

Using ... tells R that our function can accept extra arguments, which are then forwarded to another function inside it.
This lets us use the other functionâ€™s optional arguments directly.

```{r}
my_mean <- function(x, ...) {
  mean(x, ...)
}

# Here, ... allows my_mean() to use optional arguments of mean() such as na.rm = TRUE, without redefining them.

my_mean(c(1, 2, NA, 4), na.rm = TRUE)

# x is handled by my_mean
# na.rm = TRUE is captured by ... and passed to mean()


# ... argument is also necessary when we dont know how many arguments will be there

args(paste)
paste("a", "b")
paste("a", "b", "C", "d", sep=":")

# any arguments after ..., needs to be named explicitly

```

## Variable Scope in R (Basics)

Scope refers to where an object is visible and accessible in your code.
In this course, we focus only on basic function scoping, which is sufficient for most data analysis tasks.

**Local Variables in Functions**

Variables created inside a function exist only within that function.
These are called local variables.

```{r}

f <- function() {
  x <- 10
  x
}

f()

x

# Here, x is created inside the function, so it is not accessible outside.

```

**Global Variables (Outside Functions)**

Variables created outside functions exist in the global environment.

```{r}

y <- 5

g <- function() {
  y + 1
}

g()

# However, relying on global variables is not recommended.

# Best Practice: Use Function Arguments
# Instead of using global variables, always pass values as arguments.

g <- function(y) {
  y + 1
}

g(5)

```

Note on Advanced Scoping Concepts (Not Covered):

The following advanced topics are intentionally not covered in this course:

- Environments
- Lexical scoping rules
- Parent frames
- <<- operator

These concepts are mainly relevant for advanced R programming and package development, and are not required for effective data analysis.


## Dates and Time in R

R has built-in support for working with dates and time, which is useful for:

- experiment timelines
- sample collection dates
- time-series measurements

Dates are represented in class Date, and time class POSIXct or POSIXlt

POSIXct - useful when want to store dates in dataframe
POSIXlt - its a kind of list, which stored other information like day of week, day of year, month , day of month

Working with Dates

```{r}
d1 <- as.Date("2026-01-22")
d2 <- as.Date("2026-02-01")
class(d1)

# operation on days
d2 - d1

d1 + 7
d2 - 3

Sys.Date()

```

Working with Date-Time
Creating Date-Time Objects

```{r}

t1 <- as.POSIXct("2026-01-22 10:30:00")
t2 <- as.POSIXct("2026-01-22 18:00:00")

class(t1)
t2 - t1

Sys.time()

format(d1, "%Y")   # Year
format(d1, "%m")   # Month
format(d1, "%d")   # Day

format(t1, "%H")   # Hour
format(t1, "%M")   # Minute

# Common Date Operations
# Sorting by Date

dates <- as.Date(c("2026-01-05", "2026-01-01", "2026-01-03"))
sort(dates)

# Filtering Using Dates
dates[dates > as.Date("2026-01-02")]

t1 <- as.POSIXct("2026-01-22 10:30:00")
t2 <- as.POSIXct("2026-01-22 18:00:00")

### as.POSIXlt

t_lt <- as.POSIXlt("2026-01-22 10:30:45")
t_lt2 <- as.POSIXlt("2026-01-29 10:30:45")
class(t_lt)

t_lt$year 

# year is counted from 1900
# mon starts from 0 (January = 0)


t_lt2 - t_lt

format(t_lt, "%Y")
format(t_lt, "%S")
format(t_lt, "%m")

```

Parsing Date-Time from Character Strings.

Real-world data often contains dates stored as character strings, often messy way of representing.
To convert them properly, we use strptime().

```{r}

x <- "29-01-2026 10:30:00"

dt <- strptime(x, format = "%d-%m-%Y %H:%M:%S")
dt

x <- c("Jan 10, 2012 10:40")
dt <- strptime(x, format = "%B %d, %Y %H:%M")
dt

# now if you don't remember these codes in format, like i don't, always read the document ?strptime

```


Working with Dates and Time Using lubridate. (in next session in more detail)

Base R provides powerful date-time classes (Date, POSIXct, POSIXlt), but working with them can sometimes feel verbose or unintuitive, especially when parsing dates or extracting components.

The lubridate package (part of the tidyverse) is designed to make date and time handling:

## Loop Functions in R (Apply Family)

In addition to for and while loops, R provides a set of loop functions, commonly known as the apply family.
These functions allow you to apply an operation repeatedly over elements of a data structure without writing explicit loops.

Why Use Loop Functions?

- Loop functions are:
- Shorter and cleaner than manual loops
- Easier to read and maintain
- Less error-prone
- Idiomatic R (you will see them often in real code)

| Function   | Used With              | Purpose |
|-----------|------------------------|---------|
| `apply()`  | Matrix / data frame    | Apply a function over rows or columns |
| `lapply()` | List                   | Apply a function to each element (returns a list) |
| `sapply()` | List / vector          | Same as `lapply()` but simplifies output |
| `tapply()` | Vector                 | Apply a function over subsets defined by a factor |
| `mapply()` | Multiple inputs        | Vectorized version of a function |

apply() â€” Working with Rows and Columns,Used mainly with matrices or data frames.

```{r}
m <- matrix(1:12, nrow = 3)

# Apply sum to each column
apply(m, 2, sum)

# Apply mean to each row
apply(m, 1, mean)

apply(m, 1, sum)
apply(m, 1, sd)

# 2 â†’ columns
# 1 â†’ rows

```

lapply() â€” Looping Over Lists

```{r}

x <- list(a = 1:5, b = 6:10, c = 11:15)
lapply(x, mean)

# Output is always a list
```

sapply() â€” Simplified Output,  Similar to lapply(), but tries to simplify the result.

```{r}

sapply(x, mean)

```

tapply() â€” Group-wise Operations, Very useful for biological or experimental data.

```{r}
values <- c(5.1, 5.5, 6.0, 6.2, 5.8)
group  <- c("Control", "Control", "Treated", "Treated", "Treated")

tapply(values, group, mean)

# Summarizing measurements by condition, treatment, or group

```

## Getting Help in R

R has built-in help documentation.

```{r}

?mean
help(mean)

help.search("regression") # gives difference functions to perform regression using in-built functions or downloaded packages

```


## Hands-on Exercises

### Exercise 1

Create a numeric vector of 10 values and calculate:

- Mean

- Median

- Standard deviation

### Exercise 2

Create a data frame with:

- Name

- Age

- Field of study

- Display its structure and summary.

### Exercise 3

Explore the built-in iris dataset:

- View the first 6 rows

- Find the mean of Sepal.Length




