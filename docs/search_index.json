[["index.html", "R Programming for Statistical &amp; Genomic Data Analysis Day-0 : Course Overview 0.1 Course Objectives 0.2 What This Course Is Not About 0.3 Target Audience 0.4 Software Requirements 0.5 Course Structure 0.6 How to Use This Book 0.7 Suggested Reading", " R Programming for Statistical &amp; Genomic Data Analysis Author: Nikhil Sharma Course Coordinator: Shruti Kaushal 26 Jan 2026 ‚Äì 30 Jan 2026 Day-0 : Course Overview This course introduces R programming for statistical analysis, data visualization, and introductory genomic data exploration. It is designed as a hands-on, reproducible course using RMarkdown and Bookdown. 0.1 Course Objectives By the end of this course, students will be able to: Write basic R programs Manipulate and visualize data using tidyverse Perform common statistical analyses Explore genomic data using Bioconductor Produce reproducible analysis reports 0.2 What This Course Is Not About We will not focus on: Advanced programming concepts or algorithms Software engineering practices or application development Writing optimized or production-level R code 0.3 Target Audience Life science students Beginners to R programming Researchers starting data analysis No prior programming experience is required. 0.4 Software Requirements R version 4.5.x RStudio Desktop Linux (Ubuntu/Debian preferred) All installation steps are covered in the next chapter. 0.5 Course Structure Day 0: Course overview &amp; installation Day 1: R fundamentals Day 2: Data manipulation &amp; visualization Day 3: Statistical analysis Day 4: Genomic data exploration - 1 Day 5: Genomic data exploration - 2 0.6 How to Use This Book Read each chapter sequentially Run code examples locally in RStudio Attempt all hands-on exercises Use the navigation panel to move between days 0.7 Suggested Reading This course draws inspiration from the following excellent resources: Wickham, H. &amp; Grolemund, G. R for Data Science (2nd Edition) https://r4ds.hadley.nz/ Grolemund, G. Hands-On Programming with R https://rstudio-education.github.io/hopr/ Bioconductor Core Team Bioconductor Workflows https://bioconductor.org/help/workflows/ Xie, Y., Allaire, J. J., &amp; Grolemund, G. R Markdown: The Definitive Guide https://bookdown.org/yihui/rmarkdown/ Peng, R. D., Caffo, B., &amp; Leek, J. Data Science: Foundations using R Specialization. https://www.coursera.org/specializations/data-science-foundations-r ‚û°Ô∏è Proceed to Installation &amp; Environment Setup to begin. "],["day-0-installation-environment-setup-linux.html", "Day-0 : Installation &amp; Environment Setup (Linux) 0.8 Learning Objectives 0.9 Installing R (Ubuntu/Debian) 0.10 You can also follow below link for installations 0.11 Installing RStudio Desktop (Linux)", " Day-0 : Installation &amp; Environment Setup (Linux) 0.8 Learning Objectives Install R (version 4.5) Install RStudio Verify a working R environment 0.9 Installing R (Ubuntu/Debian) Run the following commands in a terminal: sudo apt update sudo apt install -y software-properties-common dirmngr sudo wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc \\ | sudo tee /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc sudo add-apt-repository &quot;deb https://cloud.r-project.org/bin/linux/ubuntu jammy-cran40/&quot; sudo apt update sudo apt install -y r-base=4.5* r-base-dev=4.5* 0.10 You can also follow below link for installations https://cran.r-project.org/bin/linux/ubuntu/ 0.11 Installing RStudio Desktop (Linux) RStudio provides a user-friendly interface for working with R. Step 1: Download RStudio Go to the official RStudio download page: https://posit.co/download/rstudio-desktop/ Download the Linux ‚Üí Debian/Ubuntu (.deb) installer. 0.11.1 Step 2: Install RStudio Navigate to the downloaded file and run: sudo dpkg -i rstudio-*.deb sudo apt --fix-broken install 0.11.2 Step 3: Launch RStudio You can start RStudio by: Searching ‚ÄúRStudio‚Äù in the application menu Or running in terminal: rstudio 0.11.3 Installing RStudio Desktop (Windows) 0.11.4 Step 1: Download RStudio Go to the official RStudio download page: https://posit.co/download/rstudio-desktop/ Download Windows Installer (.exe) 0.11.5 Step 2: Install RStudio Double-click the downloaded .exe file Follow the setup wizard (default options are sufficient) Finish installation 0.11.6 Step 3: Launch RStudio Open RStudio from: Start Menu ‚Üí RStudio OR Desktop shortcut (if created) Verify Working R Environment (Windows) In the RStudio Console, run: version "],["day-1-fundamentals-of-r-programming.html", "1 Day-1 : Fundamentals of R Programming 1.1 Learning Objectives 1.2 What Is R? 1.3 RStudio Interface (Quick Tour) 1.4 Creating Objects in R 1.5 Attributes 1.6 Using R as a Calculator 1.7 Comments 1.8 Basic Data Types 1.9 Data Structures 1.10 Vectorization: Thinking in Vectors 1.11 Working with Text (Strings) 1.12 Control Structures 1.13 functions 1.14 Variable Scope in R (Basics) 1.15 Dates and Time in R 1.16 Loop Functions in R (Apply Family) 1.17 Getting Help in R 1.18 Hands-on Exercises", " 1 Day-1 : Fundamentals of R Programming 1.1 Learning Objectives By the end of this day, students will be able to: Understand what R is and where it is used Use R as a calculator (basic operations) Create and manipulate basic R objects Work with core R data structures (vectors, lists, data frames) Understand basic program control using conditions and loops 1.2 What Is R? R is an interpreted language, where code is executed interactively and results are shown immediately. Interactively means: You type a command R executes it right away You immediately see the output or error Then you decide what to do next This interpreted behavior of R is very important for task like data Analysis and modeling. R is a programming language and environment designed for: Statistical analysis Data visualization Reproducible research R is widely used in academia, research: Statistics Epidemiology Genomics Social sciences Machine learning research One of R‚Äôs biggest strengths is its ecosystem of packages, including CRAN and Bioconductor. 1.3 RStudio Interface (Quick Tour) RStudio provides a user-friendly interface for working with R. Main components: - Console ‚Äì where commands are executed - Script Editor ‚Äì where you write and save code - Environment ‚Äì shows created objects - Plots / Files / Help ‚Äì outputs and documentation üí° Tip: Always write code in a script file, not directly in the Console. 1.4 Creating Objects in R In R, everything you work with is stored in an object. It has five basic classes of object: character, numeric, integer, complex and logical.(also data types in R) An object can be thought of as a container that has: a structure, defined by its data structure (e.g., vector, list, data frame), and values, whose nature is defined by data types (e.g., numeric, character, logical). Objects allow you to store, reuse, and manipulate data throughout your analysis. Assignment is typically done using &lt;-: x &lt;- 10 y &lt;- 3 z = 10 10 -&gt; a 20 -&gt; b Use the objects in calculations: x + y ## [1] 13 x * y ## [1] 30 1.5 Attributes In layman term you can think of them as properties of an object. names: labels for elements dim: dimensions of an object (rows and columns) dimnames: names for rows and columns class: defines the object‚Äôs behavior length: number of elements User-defined attributes: metadata x &lt;- c(10, 20, 30) # function c is used to create a vector names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) attributes(x) ## $names ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; m &lt;- matrix(1:6, nrow = 2) dimnames(m) &lt;- list( c(&quot;Row1&quot;, &quot;Row2&quot;), c(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;) ) m ## Col1 Col2 Col3 ## Row1 1 3 5 ## Row2 2 4 6 attributes(m) ## $dim ## [1] 2 3 ## ## $dimnames ## $dimnames[[1]] ## [1] &quot;Row1&quot; &quot;Row2&quot; ## ## $dimnames[[2]] ## [1] &quot;Col1&quot; &quot;Col2&quot; &quot;Col3&quot; df &lt;- data.frame(id = 1:3, score = c(80, 90, 85)) class(df) ## [1] &quot;data.frame&quot; dim(df) ## [1] 3 2 names(df) ## [1] &quot;id&quot; &quot;score&quot; # user define attributes x &lt;- c(5, 10, 15) attr(x, &quot;source&quot;) &lt;- &quot;Survey Data&quot; attr(x, &quot;collected_on&quot;) &lt;- &quot;2026-01-22&quot; attributes(x) ## $source ## [1] &quot;Survey Data&quot; ## ## $collected_on ## [1] &quot;2026-01-22&quot; attr(x, &quot;source&quot;) &lt;- NULL 1.6 Using R as a Calculator Let‚Äôs start with simple arithmetic and basic mathematical operations Summary: Common R Operators Category Operator Description Example Arithmetic + Addition 2 + 3 Arithmetic - Subtraction 5 - 2 Arithmetic * Multiplication 4 * 3 Arithmetic / Division 8 / 2 Arithmetic ^ Exponentiation 2^3 Arithmetic %% Remainder (modulus) 10 %% 3 Arithmetic %/% Integer division 10 %/% 3 Comparison == Equal to x == 5 Comparison != Not equal to x != 3 Comparison &gt; Greater than x &gt; 5 Comparison &lt; Less than x &lt; 2 Logical &amp; AND x &gt; 1 &amp; x &lt;5 Logical | OR x &lt; 2 | x &gt;8 Assignment &lt;- Assign value x &lt;- 10 2 + 3 # addition ## [1] 5 10 - 4 # sub ## [1] 6 5 * 6 # multiply ## [1] 30 8 / 2 # divide ## [1] 4 2 + 3 * 4 # multiplication first ## [1] 14 (2 + 3) * 4 # parentheses change order ## [1] 20 Additional useful operators: 2^3 # Exponentiation ## [1] 8 10 %% 4 # Remainder # (10 %% 3) ## [1] 2 10 %/% 3 # Integer division ## [1] 3 1.7 Comments Comments in R: Purpose: To explain code, add notes, or temporarily disable code. Syntax: Start with a hash symbol (#). Behavior: Ignored during execution; have no functional impact. # This is a comment x &lt;- 10 # Assign 10 to x y &lt;- 5 # Assign 5 to y x + y # Add x and y ## [1] 15 # Even if a comment appears after code, it is still ignored: x &lt;- 10 # x &lt;- 100 # This line will not be executed x ## [1] 10 1.7.1 Documentation comments using #‚Äô The #‚Äô syntax is a special type of comment used for documentation, mainly when writing functions or packages. #&#39; Add two numbers #&#39; #&#39; This function takes two numeric values and returns their sum. #&#39; add_numbers &lt;- function(a, b) { a + b } add_numbers(2,3) ## [1] 5 1.8 Basic Data Types In programming, data type is an important concept. Variables can store data of different types, and different types can do different things. Common data types in R include: 1.8.1 Summary: Basic R Data Types Data Type Description Example numeric Decimal numbers 3.14, 10.5 integer Whole numbers 10L, 5L character Text strings \"genomics\" logical Boolean values TRUE, FALSE complex Complex numbers 2 + 3i numeric_value &lt;- 3.14 # (10.5, 55, 787) integer_value &lt;- 10L # (1L, 55L, 100L, where the letter &quot;L&quot; declares this as an integer) character_value &lt;- &quot;genomics&quot; # (&quot;k&quot;, &quot;R is exciting&quot;, &quot;FALSE&quot;, &quot;11.5&quot;) logical_value &lt;- TRUE # (a.k.a. boolean) - (TRUE or FALSE) complex_value &lt;- c(9 + 3i) # where &quot;i&quot; is the imaginary part #### special numeric values Inf # 1/0 ## [1] Inf NaN # not a number (also treated as missing values) ## [1] NaN 0/0 ## [1] NaN Check the type of an object: class(numeric_value) ## [1] &quot;numeric&quot; class(character_value) ## [1] &quot;character&quot; class(logical_value) ## [1] &quot;logical&quot; Type Conversion You can convert from one type to another with the following functions: as.numeric() as.integer() as.complex() x &lt;- 5L # integer y &lt;- 7 # numeric # convert from integer to numeric: a &lt;- as.numeric(x) # convert from numeric to integer: b &lt;- as.integer(y) # print values of x and y class(x) ## [1] &quot;integer&quot; class(y) ## [1] &quot;numeric&quot; # print the class name of a and b class(a) ## [1] &quot;numeric&quot; class(b) ## [1] &quot;integer&quot; # problem with some conversion x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA as.logical(x) ## [1] NA NA NA # what is the hack here? as.numeric(as.factor(x)) ## [1] 1 2 3 1.9 Data Structures Data structures are used to store and organize data values/ types. 1.9.1 Summary: Core R Data Structures Structure Description Example Vector Same data type, 1D c(1, 2, 3) List Different data types allowed list(1, \"A\", TRUE) Factor Categorical data with levels factor(c(\"A\",\"B\")) Data Frame Tabular data, columns of equal length data.frame(x=1:3, y=c(\"A\",\"B\",\"C\")) Matrix Same data type, 2D matrix(1:6, nrow=2) Array Same data type, multi-dimensional array(1:8, dim=c(2,2,2)) R provides many built-in data structures. Each is used to handle data in different ways: 1.9.2 Vector A vector is the most basic data structure in R. It contains a list of items of the same type. numbers &lt;- c(1, 2, 3, 4, 5) genes &lt;- c(&quot;TP53&quot;, &quot;BRCA1&quot;, &quot;EGFR&quot;) flags &lt;- c(TRUE, FALSE, TRUE) # using vector function vector(&quot;numeric&quot;, length = 10) # created empty vector ## [1] 0 0 0 0 0 0 0 0 0 0 What if we mix the data types. y &lt;- c(1.7, &quot;a&quot;) y # character ## [1] &quot;1.7&quot; &quot;a&quot; y &lt;- c(TRUE, 2) y # numeric ## [1] 1 2 # this is called Coercion # every element of vector needs to be of same type # explicitly coercion: we will see in type conversion Indexing vectors: numbers[1] ## [1] 1 numbers[2:4] ## [1] 2 3 4 genes[2] ## [1] &quot;BRCA1&quot; numbers[-2] # excess all elements except 2nd ## [1] 1 3 4 5 numbers[-1:-4] # excess only 5th element ## [1] 5 1.9.3 Lists A list is a flexible data structure in R that can store different types of objects together. Unlike vectors, list elements do not have to be the same data type. Creating a List my_list &lt;- list( numbers = c(1, 2, 3), gene = &quot;TP53&quot;, flag = TRUE, data = data.frame(id = 1:3, value = c(10, 20, 30)) ) my_list ## $numbers ## [1] 1 2 3 ## ## $gene ## [1] &quot;TP53&quot; ## ## $flag ## [1] TRUE ## ## $data ## id value ## 1 1 10 ## 2 2 20 ## 3 3 30 Accessing List Elements my_list$numbers ## [1] 1 2 3 my_list[[2]] ## [1] &quot;TP53&quot; my_list[1] ## $numbers ## [1] 1 2 3 my_list[[&quot;flag&quot;]] ## [1] TRUE $ ‚Üí access by name [[]] ‚Üí extract one element [ ] ‚Üí returns a sub-list Why Lists Are Important Many R functions return results as lists. model &lt;- lm(mpg ~ wt, data = mtcars) model ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Coefficients: ## (Intercept) wt ## 37.285 -5.344 model$coefficients ## (Intercept) wt ## 37.285126 -5.344472 model$model ## mpg wt ## Mazda RX4 21.0 2.620 ## Mazda RX4 Wag 21.0 2.875 ## Datsun 710 22.8 2.320 ## Hornet 4 Drive 21.4 3.215 ## Hornet Sportabout 18.7 3.440 ## Valiant 18.1 3.460 ## Duster 360 14.3 3.570 ## Merc 240D 24.4 3.190 ## Merc 230 22.8 3.150 ## Merc 280 19.2 3.440 ## Merc 280C 17.8 3.440 ## Merc 450SE 16.4 4.070 ## Merc 450SL 17.3 3.730 ## Merc 450SLC 15.2 3.780 ## Cadillac Fleetwood 10.4 5.250 ## Lincoln Continental 10.4 5.424 ## Chrysler Imperial 14.7 5.345 ## Fiat 128 32.4 2.200 ## Honda Civic 30.4 1.615 ## Toyota Corolla 33.9 1.835 ## Toyota Corona 21.5 2.465 ## Dodge Challenger 15.5 3.520 ## AMC Javelin 15.2 3.435 ## Camaro Z28 13.3 3.840 ## Pontiac Firebird 19.2 3.845 ## Fiat X1-9 27.3 1.935 ## Porsche 914-2 26.0 2.140 ## Lotus Europa 30.4 1.513 ## Ford Pantera L 15.8 3.170 ## Ferrari Dino 19.7 2.770 ## Maserati Bora 15.0 3.570 ## Volvo 142E 21.4 2.780 model$fitted.values ## Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive ## 23.282611 21.919770 24.885952 20.102650 ## Hornet Sportabout Valiant Duster 360 Merc 240D ## 18.900144 18.793255 18.205363 20.236262 ## Merc 230 Merc 280 Merc 280C Merc 450SE ## 20.450041 18.900144 18.900144 15.533127 ## Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental ## 17.350247 17.083024 9.226650 8.296712 ## Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla ## 8.718926 25.527289 28.653805 27.478021 ## Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 ## 24.111004 18.472586 18.926866 16.762355 ## Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa ## 16.735633 26.943574 25.847957 29.198941 ## Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E ## 20.343151 22.480940 18.205363 22.427495 numbers * 2 ## [1] 2 4 6 8 10 numbers + 10 ## [1] 11 12 13 14 15 1.9.4 Matrices Matrices are special kind of vector which has dimension attribute. It has rows and columns # it is constructed as column first m &lt;- matrix(1:8) dim(m) ## [1] 8 1 attributes(m) ## $dim ## [1] 8 1 m &lt;- matrix(1:8, nrow = 3, ncol = 3) ## Warning in matrix(1:8, nrow = 3, ncol = 3): data length [8] is not a ## sub-multiple or multiple of the number of rows [3] dim(m) ## [1] 3 3 attributes(m) ## $dim ## [1] 3 3 # matrices can be created from vectors by adding dimension attribute m &lt;- 1:9 dim(m) &lt;- c(3, 3) m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # matrices can be create by cbind and rbind y &lt;- 1:3 z &lt;- 10:12 cbind(y, z) ## y z ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(y, z) ## [,1] [,2] [,3] ## y 1 2 3 ## z 10 11 12 1.9.5 Factors Factors are used to represent categorical data in R. It can be ordered or unordered. you can think of factors as integer with each integer value maps to label. factors are really important when you will proceed to statistical test or models. Because the first label is treated as baseline label. its good to have factors with labels as compare to integers, eg. male or female rather than 1 or 2. group &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;)) group ## [1] A B A B ## Levels: A B levels(group) ## [1] &quot;A&quot; &quot;B&quot; table(group) ## group ## A B ## 2 2 unclass(group) ## [1] 1 2 1 2 ## attr(,&quot;levels&quot;) ## [1] &quot;A&quot; &quot;B&quot; as.numeric(group) # this show how they are stored internally ## [1] 1 2 1 2 group &lt;- factor( c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;), levels = c(&quot;A&quot;, &quot;B&quot;), # levels use to set order labels = c(&quot;Control&quot;, &quot;Treatment&quot;) ) group ## [1] Control Treatment Control Treatment ## Levels: Control Treatment 1.9.6 Missing values Missing values are donated by NA or NaN. use is.na () to detect NA and is.nan() for NaN. These can character or numeric etc. A NaN values is also NA, but converse is not true. x &lt;- c(1, 2, NA, 4, 5) is.na(x) ## [1] FALSE FALSE TRUE FALSE FALSE is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE x &lt;- c(1, 2, NA, NaN, 5) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) ## [1] FALSE FALSE FALSE TRUE FALSE # subsetting or removing missing values # very common task in analysis x &lt;- c(1, 2, NA, 4, 5) x[!is.na(x)] ## [1] 1 2 4 5 x[complete.cases(x)] ## [1] 1 2 4 5 na.omit(x) ## [1] 1 2 4 5 ## attr(,&quot;na.action&quot;) ## [1] 3 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; data(airquality) dim(airquality) ## [1] 153 6 dim(airquality[complete.cases(airquality), ]) ## [1] 111 6 dim(na.omit(airquality)) ## [1] 111 6 1.9.7 Data Frames A data frame is a table-like structure where each column can be a different data type. Mostly well suited for tabular data as in our csv or excel files. read.csv() and read.table() ara base functions to read these files special type of list, where every list needs to be of same length. df &lt;- data.frame( id = 1:5, age = c(23, 35, 41, 29, 50), group = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;A&quot;) ) df ## id age group ## 1 1 23 A ## 2 2 35 B ## 3 3 41 A ## 4 4 29 B ## 5 5 50 A Inspecting a data frame: dim(df) ## [1] 5 3 str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ id : int 1 2 3 4 5 ## $ age : num 23 35 41 29 50 ## $ group: chr &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; ... summary(df) ## id age group ## Min. :1 Min. :23.0 Length:5 ## 1st Qu.:2 1st Qu.:29.0 Class :character ## Median :3 Median :35.0 Mode :character ## Mean :3 Mean :35.6 ## 3rd Qu.:4 3rd Qu.:41.0 ## Max. :5 Max. :50.0 head(df) ## id age group ## 1 1 23 A ## 2 2 35 B ## 3 3 41 A ## 4 4 29 B ## 5 5 50 A Accessing columns: df$age ## [1] 23 35 41 29 50 df[, &quot;group&quot;] ## [1] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; df[1, ] ## id age group ## 1 1 23 A df[10, ] ## id age group ## NA NA NA &lt;NA&gt; df[, 2] ## [1] 23 35 41 29 50 df[, 3] ## [1] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; 1.10 Vectorization: Thinking in Vectors One of the key ideas in R is vectorization. In R, most operations are designed to work on entire vectors at once, rather than one element at a time. This makes R code: Simpler to write Easier to read Faster to execute This is different from many other programming languages, where you often need loops to process each value individually. x &lt;- c(1, 2, 3, 4, 5); y &lt;- c(6, 7, 8, 9, 10) # element wise addition x+y ## [1] 7 9 11 13 15 x &gt; 3 ## [1] FALSE FALSE FALSE TRUE TRUE # vectorization x * 2 ## [1] 2 4 6 8 10 # using loop result &lt;- numeric(length(x)) for (i in seq_along(x)) { result[i] &lt;- x[i] * 2 } 1.11 Working with Text (Strings) In R, text data is stored as character vectors. A single string is a character vector of length 1, and individual characters are accessed only after explicitly splitting the string. gene_string &lt;- &quot;ATGCGATAGCGAG&quot; gene_string ## [1] &quot;ATGCGATAGCGAG&quot; Splitting a String into Characters To work with individual letters, the string must be split into a character vector. chars &lt;- strsplit(gene_string, &quot;&quot;)[[1]] chars ## [1] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot; &quot;A&quot; &quot;T&quot; &quot;A&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot; &quot;A&quot; &quot;G&quot; length(chars) ## [1] 13 # strsplit() returns a list # # [[1]] extracts the character vector # Looping Through Characters for (char in chars) { print(char) } ## [1] &quot;A&quot; ## [1] &quot;T&quot; ## [1] &quot;G&quot; ## [1] &quot;C&quot; ## [1] &quot;G&quot; ## [1] &quot;A&quot; ## [1] &quot;T&quot; ## [1] &quot;A&quot; ## [1] &quot;G&quot; ## [1] &quot;C&quot; ## [1] &quot;G&quot; ## [1] &quot;A&quot; ## [1] &quot;G&quot; Count the number of characters in a string: nchar() counts characters, not vector length. nchar(gene_string) ## [1] 13 Counting Specific Characters Finding the First Position of a Pattern: regexpr() regexpr(&quot;AG&quot;, gene_string)[1] ## [1] 8 # regexpr() finds the first occurrence of a pattern # The result gives the starting position and match length Finding All Positions of a Pattern: gregexpr() gregexpr(&quot;AG&quot;, gene_string)[[1]] ## [1] 8 12 ## attr(,&quot;match.length&quot;) ## [1] 2 2 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE # gregexpr() finds all occurrences # Returns a list of positions Find number of occurrence of particular character table(chars) ## chars ## A C G T ## 4 2 5 2 sum(chars == &quot;A&quot;) ## [1] 4 sum(chars == &quot;G&quot;) ## [1] 5 sum(strsplit(gene_string, &quot;&quot;)[[1]] == &quot;A&quot;) ## [1] 4 sum(strsplit(gene_string, &quot;&quot;)[[1]] == &quot;G&quot;) ## [1] 5 Pattern Matching Check if a pattern exists: grepl(&quot;CG&quot;, gene_string) ## [1] TRUE # Returns TRUE or FALSE Count how many times a pattern occurs: length(gregexpr(&quot;CG&quot;, gene_string)[[1]]) ## [1] 2 # gregexpr() returns match positions # length() gives the number of matches Additional Useful Base R String Functions Convert Case: tolower(gene_string) ## [1] &quot;atgcgatagcgag&quot; toupper(gene_string) ## [1] &quot;ATGCGATAGCGAG&quot; Extract Substrings from particular postion substr(gene_string, start = 1, stop = 3) ## [1] &quot;ATG&quot; Replace Text where ever the string matches sub(&quot;CG&quot;, &quot;XX&quot;, gene_string) ## [1] &quot;ATGXXATAGCGAG&quot; # Replaces the first occurrence of a pattern. gsub(&quot;CG&quot;, &quot;XX&quot;, gene_string) ## [1] &quot;ATGXXATAGXXAG&quot; # gsub() replaces all occurrences 1.12 Control Structures Control structures allow R to make decisions and repeat actions based on conditions. They are used when the flow of execution needs to change depending on the data or logic. Conditional Statements: if and else Conditional statements execute different code blocks depending on whether a condition is TRUE or FALSE. x &lt;- 3 if (x &gt; 5) { &quot;x is greater than 5&quot; } else { &quot;x is less than or equal to 5&quot; } ## [1] &quot;x is less than or equal to 5&quot; # if checks a condition # else runs when the condition is not met Vectorized Conditionals: ifelse() ifelse() applies a condition element-wise to vectors, making it useful for data analysis. x &lt;- c(3, 7, 2, 9) ifelse(x &gt; 5, &quot;High&quot;, &quot;Low&quot;) ## [1] &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;High&quot; # Works on entire vectors at once # Commonly used for creating new columns or labels for Loop A for loop repeats a block of code for each value in a sequence. for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # Useful when an operation must be repeated step-by-step # In R, vectorized solutions are often preferred when possible while Loop A while loop keeps running as long as a condition remains TRUE. x &lt;- 1 while (x &lt;= 5) { print(x) x &lt;- x + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # The condition is checked before each iteration # Be careful to update the condition to avoid infinite loops Infinite Loop (Conceptual Example) An infinite loop occurs when a loop condition never becomes FALSE. This can cause the program to run forever unless explicitly stopped. # while (TRUE) { # print(&quot;This will run forever&quot;) # } # Infinite loops usually happen due to missing or incorrect stopping conditions. 1.12.1 Loop Control: break and next Using break to Stop a Loop Early. break exits a loop before it finishes all iterations. for (i in 1:10) { if (i == 5) { break } print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 Explanation: The loop stops as soon as i becomes 5 Remaining values are not processed Use case: Stop processing when a condition of interest is reached. Using next to Skip an Iteration next skips the current iteration and continues with the next one. for (i in 1:5) { if (i == 3) { next } print(i) } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 # explanation: # # The value 3 is skipped # # All other values are processed normally # # Use case: # # Ignore missing, invalid, or unwanted values. 1.13 functions Functions are created using function() directive and stored as object. In particular, they are R object of class function. Functions can be passed as arguments to another function. functions can be nested so that you can define one function inside of other. class(mean) ## [1] &quot;function&quot; f &lt;- function(arguments) { # code to perform a task } Function Arguments: Arguments are the inputs to a function. They allow functions to work with different values without rewriting code. square &lt;- function(x) { x^2 } square(5) ## [1] 25 square(c(1, 2, 3)) ## [1] 1 4 9 # multiple arguments add_numbers &lt;- function(a, b) { a + b } # Arguments can be passed: # By position # By name add_numbers(2, 3) ## [1] 5 add_numbers(b = 3, a = 2) ## [1] 5 # Default Argument Values # Arguments can have default values, making them optional. power &lt;- function(x, exponent = 2) { x^exponent } power(4) # uses default exponent ## [1] 16 power(4, 3) # overrides default ## [1] 64 # Named vs Positional Arguments (Important) seq(from = 1, to = 10, by = 2) ## [1] 1 3 5 7 9 seq(1, 10, 2) ## [1] 1 3 5 7 9 # Named arguments improve readability and reduce errors. it is recommended to not to mess with default order, might lead to confusion. start with reading the function using ?. mydata &lt;- rnorm(100) sd(mydata) ## [1] 1.053724 sd(x = mydata) ## [1] 1.053724 sd(x = mydata, na.rm = FALSE) ## [1] 1.053724 sd(na.rm = FALSE, x = mydata) ## [1] 1.053724 # it is also possible to not define default value of argument f &lt;- function(a,b=2,c=4, d=NULL) { a^2 } # lazy evaluation: arguments are evaluated lazily, that mean they are evaluated only if they needed. f(4) # did not use any other argument except a, and didn&#39;t produce any error. ## [1] 16 # fname &lt;- function(a, b) { # print(a) # print(b) # } # fname(3) # here function will evaluate b also The ‚Ä¶ (Dot-Dot-Dot) Argument Using ‚Ä¶ tells R that our function can accept extra arguments, which are then forwarded to another function inside it. This lets us use the other function‚Äôs optional arguments directly. my_mean &lt;- function(x, ...) { mean(x, ...) } # Here, ... allows my_mean() to use optional arguments of mean() such as na.rm = TRUE, without redefining them. my_mean(c(1, 2, NA, 4), na.rm = TRUE) ## [1] 2.333333 # x is handled by my_mean # na.rm = TRUE is captured by ... and passed to mean() # ... argument is also necessary when we dont know how many arguments will be there args(paste) ## function (..., sep = &quot; &quot;, collapse = NULL, recycle0 = FALSE) ## NULL paste(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a b&quot; paste(&quot;a&quot;, &quot;b&quot;, &quot;C&quot;, &quot;d&quot;, sep=&quot;:&quot;) ## [1] &quot;a:b:C:d&quot; # any arguments after ..., needs to be named explicitly 1.14 Variable Scope in R (Basics) Scope refers to where an object is visible and accessible in your code. In this course, we focus only on basic function scoping, which is sufficient for most data analysis tasks. Local Variables in Functions Variables created inside a function exist only within that function. These are called local variables. f &lt;- function() { x &lt;- 10 x } f() ## [1] 10 x ## [1] 6 # Here, x is created inside the function, so it is not accessible outside. Global Variables (Outside Functions) Variables created outside functions exist in the global environment. y &lt;- 5 g &lt;- function() { y + 1 } g() ## [1] 6 # However, relying on global variables is not recommended. # Best Practice: Use Function Arguments # Instead of using global variables, always pass values as arguments. g &lt;- function(y) { y + 1 } g(5) ## [1] 6 Note on Advanced Scoping Concepts (Not Covered): The following advanced topics are intentionally not covered in this course: Environments Lexical scoping rules Parent frames &lt;&lt;- operator These concepts are mainly relevant for advanced R programming and package development, and are not required for effective data analysis. 1.15 Dates and Time in R R has built-in support for working with dates and time, which is useful for: experiment timelines sample collection dates time-series measurements Dates are represented in class Date, and time class POSIXct or POSIXlt POSIXct - useful when want to store dates in dataframe POSIXlt - its a kind of list, which stored other information like day of week, day of year, month , day of month Working with Dates d1 &lt;- as.Date(&quot;2026-01-22&quot;) d2 &lt;- as.Date(&quot;2026-02-01&quot;) class(d1) ## [1] &quot;Date&quot; # operation on days d2 - d1 ## Time difference of 10 days d1 + 7 ## [1] &quot;2026-01-29&quot; d2 - 3 ## [1] &quot;2026-01-29&quot; Sys.Date() ## [1] &quot;2026-01-25&quot; Working with Date-Time Creating Date-Time Objects t1 &lt;- as.POSIXct(&quot;2026-01-22 10:30:00&quot;) t2 &lt;- as.POSIXct(&quot;2026-01-22 18:00:00&quot;) class(t1) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; t2 - t1 ## Time difference of 7.5 hours Sys.time() ## [1] &quot;2026-01-25 19:15:34 IST&quot; format(d1, &quot;%Y&quot;) # Year ## [1] &quot;2026&quot; format(d1, &quot;%m&quot;) # Month ## [1] &quot;01&quot; format(d1, &quot;%d&quot;) # Day ## [1] &quot;22&quot; format(t1, &quot;%H&quot;) # Hour ## [1] &quot;10&quot; format(t1, &quot;%M&quot;) # Minute ## [1] &quot;30&quot; # Common Date Operations # Sorting by Date dates &lt;- as.Date(c(&quot;2026-01-05&quot;, &quot;2026-01-01&quot;, &quot;2026-01-03&quot;)) sort(dates) ## [1] &quot;2026-01-01&quot; &quot;2026-01-03&quot; &quot;2026-01-05&quot; # Filtering Using Dates dates[dates &gt; as.Date(&quot;2026-01-02&quot;)] ## [1] &quot;2026-01-05&quot; &quot;2026-01-03&quot; t1 &lt;- as.POSIXct(&quot;2026-01-22 10:30:00&quot;) t2 &lt;- as.POSIXct(&quot;2026-01-22 18:00:00&quot;) ### as.POSIXlt t_lt &lt;- as.POSIXlt(&quot;2026-01-22 10:30:45&quot;) t_lt2 &lt;- as.POSIXlt(&quot;2026-01-29 10:30:45&quot;) class(t_lt) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; t_lt$year ## [1] 126 # year is counted from 1900 # mon starts from 0 (January = 0) t_lt2 - t_lt ## Time difference of 7 days format(t_lt, &quot;%Y&quot;) ## [1] &quot;2026&quot; format(t_lt, &quot;%S&quot;) ## [1] &quot;45&quot; format(t_lt, &quot;%m&quot;) ## [1] &quot;01&quot; Parsing Date-Time from Character Strings. Real-world data often contains dates stored as character strings, often messy way of representing. To convert them properly, we use strptime(). x &lt;- &quot;29-01-2026 10:30:00&quot; dt &lt;- strptime(x, format = &quot;%d-%m-%Y %H:%M:%S&quot;) dt ## [1] &quot;2026-01-29 10:30:00 IST&quot; x &lt;- c(&quot;Jan 10, 2012 10:40&quot;) dt &lt;- strptime(x, format = &quot;%B %d, %Y %H:%M&quot;) dt ## [1] &quot;2012-01-10 10:40:00 IST&quot; # now if you don&#39;t remember these codes in format, like i don&#39;t, always read the document ?strptime Working with Dates and Time Using lubridate. (in next session in more detail) Base R provides powerful date-time classes (Date, POSIXct, POSIXlt), but working with them can sometimes feel verbose or unintuitive, especially when parsing dates or extracting components. The lubridate package (part of the tidyverse) is designed to make date and time handling: 1.16 Loop Functions in R (Apply Family) In addition to for and while loops, R provides a set of loop functions, commonly known as the apply family. These functions allow you to apply an operation repeatedly over elements of a data structure without writing explicit loops. Why Use Loop Functions? Loop functions are: Shorter and cleaner than manual loops Easier to read and maintain Less error-prone Idiomatic R (you will see them often in real code) Function Used With Purpose apply() Matrix / data frame Apply a function over rows or columns lapply() List Apply a function to each element (returns a list) sapply() List / vector Same as lapply() but simplifies output tapply() Vector Apply a function over subsets defined by a factor mapply() Multiple inputs Vectorized version of a function apply() ‚Äî Working with Rows and Columns,Used mainly with matrices or data frames. m &lt;- matrix(1:12, nrow = 3) # Apply sum to each column apply(m, 2, sum) ## [1] 6 15 24 33 # Apply mean to each row apply(m, 1, mean) ## [1] 5.5 6.5 7.5 apply(m, 1, sum) ## [1] 22 26 30 apply(m, 1, sd) ## [1] 3.872983 3.872983 3.872983 # 2 ‚Üí columns # 1 ‚Üí rows lapply() ‚Äî Looping Over Lists x &lt;- list(a = 1:5, b = 6:10, c = 11:15) lapply(x, mean) ## $a ## [1] 3 ## ## $b ## [1] 8 ## ## $c ## [1] 13 # Output is always a list sapply() ‚Äî Simplified Output, Similar to lapply(), but tries to simplify the result. sapply(x, mean) ## a b c ## 3 8 13 tapply() ‚Äî Group-wise Operations, Very useful for biological or experimental data. values &lt;- c(5.1, 5.5, 6.0, 6.2, 5.8) group &lt;- c(&quot;Control&quot;, &quot;Control&quot;, &quot;Treated&quot;, &quot;Treated&quot;, &quot;Treated&quot;) tapply(values, group, mean) ## Control Treated ## 5.3 6.0 # Summarizing measurements by condition, treatment, or group 1.17 Getting Help in R R has built-in help documentation. ?mean help(mean) help.search(&quot;regression&quot;) # gives difference functions to perform regression using in-built functions or downloaded packages 1.18 Hands-on Exercises 1.18.1 Exercise 1 Create a numeric vector of 10 values and calculate: Mean Median Standard deviation 1.18.2 Exercise 2 Create a data frame with: Name Age Field of study Display its structure and summary. 1.18.3 Exercise 3 Explore the built-in iris dataset: View the first 6 rows Find the mean of Sepal.Length "],["day-2-data-manipulation-and-visualization-in-r.html", "2 Day-2 : Data Manipulation and Visualization in R 2.1 Learning Objectives 2.2 Introduction to the Tidyverse 2.3 Installing and Loading Packages 2.4 Tidy Data Principles 2.5 The Pipe Operator (%&gt;%) 2.6 Data Manipulation with dplyr 2.7 Joins 2.8 Introduction to ggplot2 2.9 Exploratory Data Analysis (EDA) 2.10 Hands-on Exercises", " 2 Day-2 : Data Manipulation and Visualization in R 2.1 Learning Objectives By the end of this day, students will be able to: Understand tidy data principles Use dplyr for data manipulation Create publication-quality plots using ggplot2 Work efficiently with real-world datasets Perform basic exploratory data analysis (EDA) 2.2 Introduction to the Tidyverse The tidyverse is a collection of R packages designed for: Data manipulation Data visualization Data analysis workflows Core tidyverse packages include: ggplot2 ‚Äì data visualization dplyr ‚Äì data manipulation tidyr ‚Äì data reshaping readr ‚Äì data import tibble ‚Äì modern data frames stringr ‚Äì string manipulation forcats ‚Äì categorical data handling lubridate - makes it easier to work with dates and times readxl - data import * note: readxl is not loaded automatically with library(tidyverse) 2.3 Installing and Loading Packages Install packages (only once): # install.packages(&quot;tidyverse&quot;) Load packages (before every session): library(tidyverse) ## ‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ ## ‚úî dplyr 1.1.4 ‚úî readr 2.1.6 ## ‚úî forcats 1.0.1 ‚úî stringr 1.6.0 ## ‚úî ggplot2 4.0.1 ‚úî tibble 3.3.1 ## ‚úî lubridate 1.9.4 ‚úî tidyr 1.3.2 ## ‚úî purrr 1.2.1 ## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ ## ‚úñ dplyr::filter() masks stats::filter() ## ‚úñ dplyr::lag() masks stats::lag() ## ‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors 2.4 Tidy Data Principles A dataset is tidy if: Each variable is a column Each observation is a row Each value is a cell These principles make data easier to manipulate, visualize and analyze. 2.4.1 Working with a Real Dataset We will use the built-in iris dataset. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 2.5 The Pipe Operator (%&gt;%) When working with the tidyverse, we often perform multiple operations in sequence. The pipe operator (%&gt;%) allows us to write these steps in a clear and readable way. The pipe takes the output of one step and passes it as the input to the next step. You can read %&gt;% as ‚Äúand then‚Äù, which helps in understanding the flow of the code. Without the pipe iris[1:6, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)] ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 with pipe iris %&gt;% select(Sepal.Length, Sepal.Width) %&gt;% head() ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 The pipe allows code to be read from top to bottom, similar to a workflow. 2.6 Data Manipulation with dplyr Note: Most tidyverse functions assume that data is already in tidy format. Selecting Columns, no need to write ‚Äú‚Äù when writing name of columns iris %&gt;% select(Sepal.Length, Sepal.Width) %&gt;% head(10) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 ## 7 4.6 3.4 ## 8 5.0 3.4 ## 9 4.4 2.9 ## 10 4.9 3.1 Exclude columns: iris %&gt;% select(-Species) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 Filtering Rows iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Multiple conditions: iris %&gt;% filter(Sepal.Length &gt; 5, Species == &quot;virginica&quot;) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.3 3.3 6.0 2.5 virginica ## 2 5.8 2.7 5.1 1.9 virginica ## 3 7.1 3.0 5.9 2.1 virginica ## 4 6.3 2.9 5.6 1.8 virginica ## 5 6.5 3.0 5.8 2.2 virginica ## 6 7.6 3.0 6.6 2.1 virginica Creating New Variables (mutate) iris %&gt;% mutate( Sepal.Area = Sepal.Length * Sepal.Width ) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Area ## 1 5.1 3.5 1.4 0.2 setosa 17.85 ## 2 4.9 3.0 1.4 0.2 setosa 14.70 ## 3 4.7 3.2 1.3 0.2 setosa 15.04 ## 4 4.6 3.1 1.5 0.2 setosa 14.26 ## 5 5.0 3.6 1.4 0.2 setosa 18.00 ## 6 5.4 3.9 1.7 0.4 setosa 21.06 Sorting Data (arrange) ascending: iris %&gt;% arrange(Sepal.Length)%&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 4.3 3.0 1.1 0.1 setosa ## 2 4.4 2.9 1.4 0.2 setosa ## 3 4.4 3.0 1.3 0.2 setosa ## 4 4.4 3.2 1.3 0.2 setosa ## 5 4.5 2.3 1.3 0.3 setosa ## 6 4.6 3.1 1.5 0.2 setosa descending iris %&gt;% arrange(desc(Sepal.Length))%&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.9 3.8 6.4 2.0 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2.0 virginica ## 5 7.7 3.0 6.1 2.3 virginica ## 6 7.6 3.0 6.6 2.1 virginica Summarizing Data (summarise) iris %&gt;% summarise( mean_sepal_length = mean(Sepal.Length), sd_sepal_length = sd(Sepal.Length) ) ## mean_sepal_length sd_sepal_length ## 1 5.843333 0.8280661 Grouped Operations (group_by) This allow us to perform summaries separately for each group in the data. iris %&gt;% group_by(Species) %&gt;% summarise( mean_sepal_length = mean(Sepal.Length), mean_petal_length = mean(Petal.Length) ) ## # A tibble: 3 √ó 3 ## Species mean_sepal_length mean_petal_length ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 1.46 ## 2 versicolor 5.94 4.26 ## 3 virginica 6.59 5.55 rename() ‚Äî Rename Columns Used to make column names shorter or more meaningful. iris %&gt;% rename( SL = Sepal.Length, SW = Sepal.Width ) %&gt;% head() ## SL SW Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa distinct() ‚Äî Keep Unique Rows Used to remove duplicate rows or extract unique values. iris %&gt;% distinct(Species) ## Species ## 1 setosa ## 2 versicolor ## 3 virginica iris %&gt;% distinct(Species, Sepal.Length) ## Species Sepal.Length ## 1 setosa 5.1 ## 2 setosa 4.9 ## 3 setosa 4.7 ## 4 setosa 4.6 ## 5 setosa 5.0 ## 6 setosa 5.4 ## 7 setosa 4.4 ## 8 setosa 4.8 ## 9 setosa 4.3 ## 10 setosa 5.8 ## 11 setosa 5.7 ## 12 setosa 5.2 ## 13 setosa 5.5 ## 14 setosa 4.5 ## 15 setosa 5.3 ## 16 versicolor 7.0 ## 17 versicolor 6.4 ## 18 versicolor 6.9 ## 19 versicolor 5.5 ## 20 versicolor 6.5 ## 21 versicolor 5.7 ## 22 versicolor 6.3 ## 23 versicolor 4.9 ## 24 versicolor 6.6 ## 25 versicolor 5.2 ## 26 versicolor 5.0 ## 27 versicolor 5.9 ## 28 versicolor 6.0 ## 29 versicolor 6.1 ## 30 versicolor 5.6 ## 31 versicolor 6.7 ## 32 versicolor 5.8 ## 33 versicolor 6.2 ## 34 versicolor 6.8 ## 35 versicolor 5.4 ## 36 versicolor 5.1 ## 37 virginica 6.3 ## 38 virginica 5.8 ## 39 virginica 7.1 ## 40 virginica 6.5 ## 41 virginica 7.6 ## 42 virginica 4.9 ## 43 virginica 7.3 ## 44 virginica 6.7 ## 45 virginica 7.2 ## 46 virginica 6.4 ## 47 virginica 6.8 ## 48 virginica 5.7 ## 49 virginica 7.7 ## 50 virginica 6.0 ## 51 virginica 6.9 ## 52 virginica 5.6 ## 53 virginica 6.2 ## 54 virginica 6.1 ## 55 virginica 7.4 ## 56 virginica 7.9 ## 57 virginica 5.9 slice() ‚Äî Select Rows by Position Used when you want rows based on row numbers, not conditions. iris %&gt;% slice(1:5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa iris %&gt;% slice((n() - 4):n()) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.7 3.0 5.2 2.3 virginica ## 2 6.3 2.5 5.0 1.9 virginica ## 3 6.5 3.0 5.2 2.0 virginica ## 4 6.2 3.4 5.4 2.3 virginica ## 5 5.9 3.0 5.1 1.8 virginica pull() ‚Äî Extract a Column as a Vector Converts a data frame column into a plain vector. species_vec &lt;- iris %&gt;% pull(Species) species_vec ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica sample_n() ‚Äî Randomly Sample Rows Randomly select a fixed number of rows. iris %&gt;% sample_n(10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.3 2.3 4.4 1.3 versicolor ## 2 6.9 3.1 5.4 2.1 virginica ## 3 4.6 3.2 1.4 0.2 setosa ## 4 5.7 2.9 4.2 1.3 versicolor ## 5 5.6 3.0 4.5 1.5 versicolor ## 6 6.3 3.3 4.7 1.6 versicolor ## 7 6.5 2.8 4.6 1.5 versicolor ## 8 7.0 3.2 4.7 1.4 versicolor ## 9 5.7 3.0 4.2 1.2 versicolor ## 10 5.8 2.7 5.1 1.9 virginica sample_frac() ‚Äî Sample a Fraction of Rows Randomly select a fraction of the dataset. iris %&gt;% sample_frac(0.1) # 10% of the data ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 4.9 3.0 1.4 0.2 setosa ## 2 4.6 3.1 1.5 0.2 setosa ## 3 7.7 2.8 6.7 2.0 virginica ## 4 6.0 3.4 4.5 1.6 versicolor ## 5 6.7 3.3 5.7 2.5 virginica ## 6 4.6 3.2 1.4 0.2 setosa ## 7 7.2 3.6 6.1 2.5 virginica ## 8 7.7 3.8 6.7 2.2 virginica ## 9 6.4 2.7 5.3 1.9 virginica ## 10 4.8 3.4 1.9 0.2 setosa ## 11 6.8 3.2 5.9 2.3 virginica ## 12 7.7 3.0 6.1 2.3 virginica ## 13 4.4 3.2 1.3 0.2 setosa ## 14 6.9 3.2 5.7 2.3 virginica ## 15 6.3 2.7 4.9 1.8 virginica 2.7 Joins Joining datasets is common in biology (samples + metadata # Example datasets df1 &lt;- tibble(ID = 1:3, Value = c(10,20,30)) df2 &lt;- tibble(ID = 2:4, Group = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) # Inner join inner_join(df1, df2, by = &quot;ID&quot;) ## # A tibble: 2 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 20 A ## 2 3 30 B # Left join left_join(df1, df2, by = &quot;ID&quot;) ## # A tibble: 3 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 10 &lt;NA&gt; ## 2 2 20 A ## 3 3 30 B # right join right_join(df1, df2, by = &quot;ID&quot;) ## # A tibble: 3 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 20 A ## 2 3 30 B ## 3 4 NA C # full join df &lt;- full_join(df1, df2, by = &quot;ID&quot;) df %&gt;% drop_na() # removing all nas dplyr function ## # A tibble: 2 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 20 A ## 2 3 30 B # drop by condition df %&gt;% filter(!is.na(Value)) ## # A tibble: 3 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 10 &lt;NA&gt; ## 2 2 20 A ## 3 3 30 B df %&gt;% filter(!is.na(Group)) ## # A tibble: 3 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 20 A ## 2 3 30 B ## 3 4 NA C df %&gt;% filter(!is.na(Group) | !is.na(Value)) ## # A tibble: 4 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 10 &lt;NA&gt; ## 2 2 20 A ## 3 3 30 B ## 4 4 NA C df %&gt;% filter(!is.na(Group) &amp; !is.na(Value)) ## # A tibble: 2 √ó 3 ## ID Value Group ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 20 A ## 2 3 30 B 2.7.1 Reshaping Data (tidyr) library(tidyr) library(tibble) gene_expression_wide &lt;- tibble( Gene = c(&quot;BRCA1&quot;, &quot;TP53&quot;, &quot;EGFR&quot;), Sample_A = c(12.5, 8.3, 15.2), Sample_B = c(13.1, 9.0, 14.8), Sample_C = c(11.9, 8.7, 16.0) ) gene_expression_wide ## # A tibble: 3 √ó 4 ## Gene Sample_A Sample_B Sample_C ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 # Each row = a gene # Each column = a sample # This is easy for humans to read but not tidy. # Wideto Long (Tidy Format) # Convert sample columns into rows using pivot_longer(). gene_expression_long &lt;- gene_expression_wide %&gt;% pivot_longer( cols = starts_with(&quot;Sample&quot;), names_to = &quot;Sample&quot;, values_to = &quot;Expression&quot; ) gene_expression_long ## # A tibble: 9 √ó 3 ## Gene Sample Expression ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 BRCA1 Sample_A 12.5 ## 2 BRCA1 Sample_B 13.1 ## 3 BRCA1 Sample_C 11.9 ## 4 TP53 Sample_A 8.3 ## 5 TP53 Sample_B 9 ## 6 TP53 Sample_C 8.7 ## 7 EGFR Sample_A 15.2 ## 8 EGFR Sample_B 14.8 ## 9 EGFR Sample_C 16 # easy inetegration with ggplot format ggplot(gene_expression_long, aes(x = Sample, y = Expression, fill = Gene)) + geom_col(position = &quot;dodge&quot;) + labs( title = &quot;Gene Expression Across Samples&quot;, y = &quot;Expression Level&quot; ) # Long to Wide (When Needed) # Sometimes, you need to go back to wide format (e.g., for export or specific tools). gene_expression_wide_again &lt;- gene_expression_long %&gt;% pivot_wider( names_from = Sample, values_from = Expression ) gene_expression_wide_again ## # A tibble: 3 √ó 4 ## Gene Sample_A Sample_B Sample_C ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 # time dependent data time_course &lt;- tibble( Gene = c(&quot;MYC&quot;, &quot;MYC&quot;, &quot;MYC&quot;, &quot;TP53&quot;, &quot;TP53&quot;, &quot;TP53&quot;, &quot;EGFR&quot;, &quot;EGFR&quot;, &quot;EGFR&quot;), Time = c(&quot;0h&quot;, &quot;6h&quot;, &quot;12h&quot;, &quot;0h&quot;, &quot;6h&quot;, &quot;12h&quot;, &quot;0h&quot;, &quot;6h&quot;, &quot;12h&quot;), Expression = c( 5.2, 8.1, 12.4, # MYC 7.5, 6.8, 5.9, # TP53 10.1, 12.3, 14.8 # EGFR ) ) time_course ## # A tibble: 9 √ó 3 ## Gene Time Expression ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 MYC 0h 5.2 ## 2 MYC 6h 8.1 ## 3 MYC 12h 12.4 ## 4 TP53 0h 7.5 ## 5 TP53 6h 6.8 ## 6 TP53 12h 5.9 ## 7 EGFR 0h 10.1 ## 8 EGFR 6h 12.3 ## 9 EGFR 12h 14.8 time_course %&gt;% pivot_wider( names_from = Time, values_from = Expression ) ## # A tibble: 3 √ó 4 ## Gene `0h` `6h` `12h` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 MYC 5.2 8.1 12.4 ## 2 TP53 7.5 6.8 5.9 ## 3 EGFR 10.1 12.3 14.8 ggplot(time_course, aes(x = Time, y = Expression, color = Gene, group = Gene)) + geom_line() + geom_point() + labs( title = &quot;Gene Expression Time Course&quot;, y = &quot;Expression Level&quot; ) When Column Names Are Badly Named Suppose the dataset came from an external source with inconsistent naming: gene_expression_bad &lt;- tibble( `Gene ID` = c(&quot;BRCA1&quot;, &quot;TP53&quot;, &quot;EGFR&quot;), `Sample A (day 0)` = c(12.5, 8.3, 15.2), `Sample-B day6` = c(13.1, 9.0, 14.8), `sample_c_day_12` = c(11.9, 8.7, 16.0) ) gene_expression_bad ## # A tibble: 3 √ó 4 ## `Gene ID` `Sample A (day 0)` `Sample-B day6` sample_c_day_12 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 # Problems: # Spaces and special characters # Inconsistent capitalization # Hard to use in code # Cleaning Column Names (Recommended Workflow) # Rename Manually Using rename() gene_expression_clean &lt;- gene_expression_bad %&gt;% rename( Gene = `Gene ID`, Sample_A = `Sample A (day 0)`, Sample_B = `Sample-B day6`, Sample_C = `sample_c_day_12` ) gene_expression_clean ## # A tibble: 3 √ó 4 ## Gene Sample_A Sample_B Sample_C ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 # Use this when: # Dataset is small # You want full control over names # Clean Names Automatically (Common in Practice) library(janitor) ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test gene_expression_auto &lt;- gene_expression_bad %&gt;% janitor::clean_names() gene_expression_auto ## # A tibble: 3 √ó 4 ## gene_id sample_a_day_0 sample_b_day6 sample_c_day_12 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 Converting Columns to Rows (Wide ‚Üí Long) gene_expression_wide &lt;- tibble( Gene = c(&quot;BRCA1&quot;, &quot;TP53&quot;, &quot;EGFR&quot;), Sample_A = c(12.5, 8.3, 15.2), Sample_B = c(13.1, 9.0, 14.8), Sample_C = c(11.9, 8.7, 16.0) ) gene_expression_wide ## # A tibble: 3 √ó 4 ## Gene Sample_A Sample_B Sample_C ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BRCA1 12.5 13.1 11.9 ## 2 TP53 8.3 9 8.7 ## 3 EGFR 15.2 14.8 16 # Step 1: Convert to Matrix (Required for Transpose) # Transposition works on matrices, not tibbles. expr_matrix &lt;- gene_expression_wide %&gt;% column_to_rownames(&quot;Gene&quot;) %&gt;% as.matrix() expr_matrix ## Sample_A Sample_B Sample_C ## BRCA1 12.5 13.1 11.9 ## TP53 8.3 9.0 8.7 ## EGFR 15.2 14.8 16.0 expr_matrix_t &lt;- t(expr_matrix) expr_matrix_t ## BRCA1 TP53 EGFR ## Sample_A 12.5 8.3 15.2 ## Sample_B 13.1 9.0 14.8 ## Sample_C 11.9 8.7 16.0 expr_df &lt;- as.data.frame(expr_matrix_t) expr_df ## BRCA1 TP53 EGFR ## Sample_A 12.5 8.3 15.2 ## Sample_B 13.1 9.0 14.8 ## Sample_C 11.9 8.7 16.0 # keep row names as column, often help ful expr_df %&gt;% rownames_to_column(&quot;Sample&quot;) ## Sample BRCA1 TP53 EGFR ## 1 Sample_A 12.5 8.3 15.2 ## 2 Sample_B 13.1 9.0 14.8 ## 3 Sample_C 11.9 8.7 16.0 2.8 Introduction to ggplot2 ggplot2 is based on the Grammar of Graphics, which means plots are built by combining independent components. Core Components of a ggplot Data: the dataset you want to visualize Aesthetics (aes): how variables map to visual properties (x, y, color, size, etc.) Geometries (geom_*): the type of plot (points, lines, bars, boxes, ‚Ä¶) Basic structure: # ggplot(data, aes(x = variable1, y = variable2)) + # geom_* 2.8.1 Basic Scatter Plot Relationship Between Two Variables Question answered: Are two numeric variables related? ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() Adding Color and Labels ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() + labs( title = &quot;Sepal Length vs Width&quot;, x = &quot;Sepal Length&quot;, y = &quot;Sepal Width&quot; ) # Use case (biology): # Comparing morphological measurements across species groups. 2.8.2 Scatter Plot with Trend Line Question answered: Is there an overall trend or correlation? ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; # what if we fit regression group wise ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; # combine group and overall trend ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;black&quot;) + geom_smooth( aes(color = Species), method = &quot;lm&quot;, se = FALSE ) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using formula = &#39;y ~ x&#39; # In biological data, different groups (species, treatments, conditions) often show different relationships. # Grouped regression lines help reveal these group-specific patterns. 2.8.3 Boxplots Compare Distributions Across Groups Question answered: How does a numeric variable differ between groups? ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species)) + geom_boxplot() # Use case (biology): # Comparing gene expression, cell size, or phenotype across conditions. 2.8.4 Histograms Distribution of a Single Variable Question answered: How is a variable distributed? ggplot(iris, aes(x = Sepal.Length)) + geom_histogram(bins = 20) # histogram by group ggplot(iris, aes(x = Sepal.Length, fill = Species)) + geom_histogram(bins = 20, alpha = 0.6) 2.8.5 Density Plots Smooth Distribution Comparing distributions without binning effects. ggplot(iris, aes(x = Sepal.Length)) + geom_density() # by group ggplot(iris, aes(x = Sepal.Length, color = Species)) + geom_density() Violin Plots Distribution Shape + Spread (density plot or histogram + boxplot) ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species)) + geom_violin(trim = FALSE) Bar Plots Counts and Summaries Count of Observations per Group ggplot(iris, aes(x = Species)) + geom_bar() ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species)) + stat_summary(fun = mean, geom = &quot;bar&quot;) + stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width = 0.2) Line Plots Trends Over Time Example: simulated time-course data time_course &lt;- tibble( Time = c(0, 6, 12), Expression = c(5.2, 8.1, 12.4) ) ggplot(time_course, aes(x = Time, y = Expression)) + geom_line() + geom_point() # Gene expression over time or treatment duration. Faceting (Multiple Plots by Group) ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() + facet_wrap(~ Species) # Use case: # Compare patterns across experimental conditions side-by-side. 2.8.6 Venn Diagrams Used for: Overlap of genes between experiments Shared pathways Common differentially expressed genes # if (!require(devtools)) install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;yanlinlin82/ggvenn&quot;) set.seed(20190708) genes &lt;- paste(&quot;gene&quot;,1:1000,sep=&quot;&quot;) x &lt;- list( A = sample(genes,300), B = sample(genes,525), C = sample(genes,440), D = sample(genes,350) ) library(ggvenn) ggvenn( x, fill_color = c(&quot;#0073C2FF&quot;, &quot;#EFC000FF&quot;, &quot;#868686FF&quot;, &quot;#CD534CFF&quot;), stroke_size = 0.5, set_name_size = 4 ) library(pheatmap) # Create a hypothetical gene expression matrix expression_matrix &lt;- matrix( c( 8.2, 6.1, 7.4, 5.9, 3.2, 2.8, 3.5, 2.9, 10.5, 11.2, 9.8, 10.1, 4.6, 5.1, 4.8, 5.3, 7.9, 8.4, 8.1, 8.7 ), nrow = 5, byrow = TRUE ) # Add gene names (rows) rownames(expression_matrix) &lt;- c( &quot;BRCA1&quot;, &quot;TP53&quot;, &quot;EGFR&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot; ) # Add sample names (columns) colnames(expression_matrix) &lt;- c( &quot;Sample_1&quot;, &quot;Sample_2&quot;, &quot;Sample_3&quot;, &quot;Sample_4&quot; ) expression_matrix ## Sample_1 Sample_2 Sample_3 Sample_4 ## BRCA1 8.2 6.1 7.4 5.9 ## TP53 3.2 2.8 3.5 2.9 ## EGFR 10.5 11.2 9.8 10.1 ## MYC 4.6 5.1 4.8 5.3 ## CDKN1A 7.9 8.4 8.1 8.7 pheatmap(expression_matrix, cluster_rows = FALSE, cluster_cols = FALSE) pheatmap(expression_matrix) Combining dplyr and ggplot2 iris %&gt;% filter(Species != &quot;setosa&quot;) %&gt;% ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() 2.9 Exploratory Data Analysis (EDA) Exploratory Data Analysis (EDA) is the process of examining and summarizing data to understand its main characteristics before applying formal statistical models. EDA relies heavily on visualization and simple summaries, rather than statistical tests. Why EDA is important EDA helps you to: Understand the structure and shape of the data Detect outliers and unusual observations Identify patterns and relationships Compare groups Assess data quality Generate hypotheses for further analysis 2.9.1 Understanding the Structure of the Data Before any analysis, always inspect the data. summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## This helps answer: What variables are present? Are they numeric or categorical? Are ranges reasonable? 2.9.2 Checking for Missing Values colSums(is.na(iris)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 0 0 0 0 0 # can you write this in tidyverse way? 2.9.3 Understanding Distributions Histogram (distribution of a numeric variable) ggplot(iris, aes(x = Sepal.Length)) + geom_histogram(bins = 30) + labs( title = &quot;Distribution of Sepal Length&quot;, x = &quot;Sepal Length&quot;, y = &quot;Count&quot; ) Questions to ask: Is the distribution symmetric or skewed? Are there extreme values? 2.9.4 Identifying Outliers ggplot(iris, aes(y = Sepal.Length)) + geom_boxplot() + labs( title = &quot;Boxplot of Sepal Length&quot;, y = &quot;Sepal Length&quot; ) Boxplots are useful for spotting: Outliers Spread of the data Median values 2.9.5 Comparing Groups Boxplot by group ggplot(iris, aes(x = Species, y = Sepal.Length, fill = Species)) + geom_boxplot() + labs( title = &quot;Sepal Length by Species&quot;, x = &quot;Species&quot;, y = &quot;Sepal Length&quot; ) This helps answer: Do groups differ in central tendency? Is variability similar across groups? 2.9.6 Exploring Relationships Between Variables Scatter plot ggplot(iris, aes(x = Petal.Length, y = Petal.Width)) + geom_point() + labs( title = &quot;Petal Length vs Petal Width&quot;, x = &quot;Petal Length&quot;, y = &quot;Petal Width&quot; ) Scatter plot with grouping ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + labs( title = &quot;Petal Length vs Petal Width by Species&quot; ) Questions to ask: Are variables related? Do relationships differ by group? 2.9.7 Simple Group Summaries iris %&gt;% group_by(Species) %&gt;% summarise( mean_sepal_length = mean(Sepal.Length), sd_sepal_length = sd(Sepal.Length) ) ## # A tibble: 3 √ó 3 ## Species mean_sepal_length sd_sepal_length ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 0.352 ## 2 versicolor 5.94 0.516 ## 3 virginica 6.59 0.636 These summaries describe patterns, not statistical significance. 2.9.8 EDA vs Statistical Analysis EDA answers: What does the data look like? Statistical analysis answers: Are the observed differences statistically significant? Formal hypothesis testing will be covered in week-3 in Statistics sessions. Will give introduction in next session from prospect of analysis. Good EDA helps you: Understand your data Avoid incorrect assumptions Ask better scientific questions 2.10 Hands-on Exercises 2.10.1 Exercise 1 Using iris dataset: Filter only versicolor Select Sepal.Length and Petal.Length 2.10.2 Exercise 2 Create a new column: Petal.ratio = Petal.Length to Petal.Width 2.10.3 Exercise 3 Create a plot: X-axis: Petal.Length Y-axis: Petal.Width Color by Species 2.10.4 Exercise 4 (Challenge) Calculate mean Sepal.Length for each species and visualize it using a bar plot. "],["day-3-statistical-analysis-using-r.html", "3 Day-3 : Statistical Analysis Using R 3.1 Learning Objectives 3.2 Types of Data 3.3 Introduction to Probability 3.4 Descriptive Statistics 3.5 Introduction to Hypothesis Testing 3.6 Machine Learning (Statistical Learning): A Gentle Introduction 3.7 Hands-on Exercises", " 3 Day-3 : Statistical Analysis Using R 3.1 Learning Objectives By the end of this day, students will be able to: Understand descriptive and inferential statistics Summarize data numerically and graphically Understand the role of probability in statistics Perform common hypothesis tests in R Interpret p-values and confidence intervals Fit and interpret basic statistical models 3.2 Types of Data Understanding data types is essential for choosing the right statistical test. Also these are default data type in many statistical packages. Numeric ‚Äì continuous or discrete values Categorical ‚Äì groups or labels Binary ‚Äì two outcomes (e.g., yes/no) 3.2.1 Why Do We Need Statistics? In biology, data are variable by nature. Even under controlled conditions, measurements differ due to biological and technical variability. Statistics provides tools to summarize data, quantify uncertainty, and draw conclusions from samples. Key ideas: Data ‚â† truth Samples ‚â† populations Variation is normal Before we can do statistics meaningfully, we need a basic understanding of probability, because: Statistics is built on probability. Probability helps us describe randomness, variation, and uncertainty in data. In other words: Probability explains why results vary Statistics helps us make decisions despite that variation 3.3 Introduction to Probability Statistics is built on the idea of random variation. In practice: We observe data from a sample Samples vary due to randomness Probability helps us quantify uncertainty 3.3.1 Populations vs Samples Population: The complete set of possible outcomes (e.g., all students in the class). Sample: A subset of the population (e.g., a random group of students measured for some trait). Suppose you have 50 students, and you want to predict the gender distribution. You know historically your class has roughly equal number of males and females set.seed(123) # Simulate the population of 50 students (M = male, F = female) students &lt;- sample(c(&quot;M&quot;, &quot;F&quot;), size = 50, replace = TRUE) table(students) ## students ## F M ## 20 30 # Notice that the number of males and females in your sample can vary just by chance. 3.3.2 Sampling Distribution What if you take random samples of 10 students from your class multiple times? Each sample will have a different number of males and females ‚Äî this is sampling variation. set.seed(123) sample_gender_counts &lt;- replicate(1000, { sample10 &lt;- sample(students, 10) sum(sample10 == &quot;M&quot;) # count number of males in each sample }) # Visualize hist(sample_gender_counts, main = &quot;Distribution of Male Students in Random Samples of 10&quot;, xlab = &quot;Number of Males&quot;, col = &quot;lightblue&quot;, breaks = 0:10) abline(v = mean(sample_gender_counts), col = &quot;red&quot;, lwd = 2) Each bar shows how likely a particular number of males occurs in a random sample of 10 students. The red line shows the average number of males across all samples. This histogram is a sampling distribution, the foundation of statistical inference. 3.3.3 Probability as ‚ÄúLong-Run Frequency‚Äù Probability tells us how likely an event is in repeated experiments. # Probability that a random sample of 10 students has exactly 5 males mean(sample_gender_counts == 5) ## [1] 0.214 mean(sample_gender_counts == 2) ## [1] 0.007 # If you repeat sampling many times, this fraction approximates the probability. # This is exactly what a p-value measures in hypothesis testing. Variation in results does not always imply a real difference ‚Äî it may be due to chance. 3.3.4 Connecting to Statistics Once we understand variation and probability: We can estimate population proportions (e.g., % male/female in class). We can test hypotheses (e.g., is the class gender ratio equal?). # One-sample proportion test: Is the proportion of males 0.5? prop.test(sum(students == &quot;M&quot;), length(students), p = 0.5) ## ## 1-sample proportions test with continuity correction ## ## data: sum(students == &quot;M&quot;) out of length(students), null probability 0.5 ## X-squared = 1.62, df = 1, p-value = 0.2031 ## alternative hypothesis: true p is not equal to 0.5 ## 95 percent confidence interval: ## 0.4520484 0.7326707 ## sample estimates: ## p ## 0.6 # The p-value tells us if the observed proportion of males significantly differs from 50%. 3.4 Descriptive Statistics Descriptive statistics summarize the main characteristics of data. 3.4.1 Numeric Summaries mean(iris$Sepal.Length) ## [1] 5.843333 median(iris$Sepal.Length) ## [1] 5.8 sd(iris$Sepal.Length) ## [1] 0.8280661 range(iris$Sepal.Length) ## [1] 4.3 7.9 3.4.2 Grouped summaries: library(dplyr) iris %&gt;% group_by(Species) %&gt;% summarise( mean_sepal = mean(Sepal.Length), sd_sepal = sd(Sepal.Length) ) ## # A tibble: 3 √ó 3 ## Species mean_sepal sd_sepal ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 0.352 ## 2 versicolor 5.94 0.516 ## 3 virginica 6.59 0.636 3.4.3 Visualizing Distributions Histogram library(ggplot2) ggplot(iris, aes(x = Sepal.Length)) + geom_histogram(bins = 20) Boxplot ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_boxplot() 3.5 Introduction to Hypothesis Testing Hypothesis testing uses probability to evaluate whether observed differences are likely due to random variation or represent a real effect. 3.5.1 Key concepts: Null hypothesis (H‚ÇÄ): no effect or no difference Alternative hypothesis (H‚ÇÅ): effect or difference exists p-value: probability of observing the data or statistics assuming H‚ÇÄ is true 3.5.2 t-test One-Sample t-test Tests whether the mean differs from a known value. t.test(iris$Sepal.Length, mu = 5) ## ## One Sample t-test ## ## data: iris$Sepal.Length ## t = 12.473, df = 149, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean is not equal to 5 ## 95 percent confidence interval: ## 5.709732 5.976934 ## sample estimates: ## mean of x ## 5.843333 3.5.3 Two-Sample t-test Compare Sepal Length between two species. t.test( Sepal.Length ~ Species, data = subset(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) ) ## ## Welch Two Sample t-test ## ## data: Sepal.Length by Species ## t = -10.521, df = 86.538, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means between group setosa and group versicolor is not equal to 0 ## 95 percent confidence interval: ## -1.1057074 -0.7542926 ## sample estimates: ## mean in group setosa mean in group versicolor ## 5.006 5.936 3.5.4 Non-Parametric Test: Wilcoxon Test Used when data do not meet t-test assumptions. wilcox.test( Sepal.Length ~ Species, data = subset(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: Sepal.Length by Species ## W = 168.5, p-value = 8.346e-14 ## alternative hypothesis: true location shift is not equal to 0 3.5.5 Analysis of Variance (ANOVA) ANOVA compares means across more than two groups. anova_model &lt;- aov(Sepal.Length ~ Species, data = iris) summary(anova_model) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Species 2 63.21 31.606 119.3 &lt;2e-16 *** ## Residuals 147 38.96 0.265 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Post-hoc Test TukeyHSD(anova_model) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = Sepal.Length ~ Species, data = iris) ## ## $Species ## diff lwr upr p adj ## versicolor-setosa 0.930 0.6862273 1.1737727 0 ## virginica-setosa 1.582 1.3382273 1.8257727 0 ## virginica-versicolor 0.652 0.4082273 0.8957727 0 3.5.6 Correlation Analysis Correlation measures the strength of association between two variables. cor(iris$Sepal.Length, iris$Petal.Length) ## [1] 0.8717538 Test for significance: cor.test(iris$Sepal.Length, iris$Petal.Length) ## ## Pearson&#39;s product-moment correlation ## ## data: iris$Sepal.Length and iris$Petal.Length ## t = 21.646, df = 148, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.8270363 0.9055080 ## sample estimates: ## cor ## 0.8717538 3.5.7 Linear Regression Linear regression models the relationship between variables. lm_model &lt;- lm(Sepal.Length ~ Petal.Length, data = iris) summary(lm_model) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.24675 -0.29657 -0.01515 0.27676 1.00269 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.30660 0.07839 54.94 &lt;2e-16 *** ## Petal.Length 0.40892 0.01889 21.65 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4071 on 148 degrees of freedom ## Multiple R-squared: 0.76, Adjusted R-squared: 0.7583 ## F-statistic: 468.6 on 1 and 148 DF, p-value: &lt; 2.2e-16 3.5.8 Visualizing the Regression ggplot(iris, aes(x = Petal.Length, y = Sepal.Length)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = TRUE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Model Diagnostics (Brief Overview) par(mfrow = c(2, 2)) plot(lm_model) 3.5.9 Interpreting Statistical Results When reporting results, always consider: Effect size Confidence intervals p-values Practical or biological relevance ‚ö†Ô∏è Statistical significance does not always imply practical importance. 3.6 Machine Learning (Statistical Learning): A Gentle Introduction In this course, machine learning is introduced as an extension of statistical modeling, with a different primary goal. While traditional statistical analysis often focuses on: - Estimating effects - Hypothesis testing - Interpretation Machine learning (also called statistical learning) focuses on: - Prediction - Generalization to new data - Model performance on unseen observations 3.6.1 Statistics vs Machine Learning (Conceptual View) Aspect Statistical Modeling Machine Learning Primary goal Inference &amp; explanation Prediction Key questions ‚ÄúIs this effect real?‚Äù ‚ÄúHow well does this predict?‚Äù Outputs Coefficients, p-values Predictions, errors Evaluation p-values, confidence intervals Prediction error Both approaches use the same data, and often the same models, but answer different questions. 3.6.2 A Simple Example: Linear Regression as Machine Learning Linear regression can be used not only for inference, but also for prediction. set.seed(123) # Simulated data x &lt;- rnorm(100) y &lt;- 2 * x + rnorm(100) # Train-test split train_id &lt;- sample(seq_along(x), 70) x_train &lt;- x[train_id] y_train &lt;- y[train_id] x_test &lt;- x[-train_id] y_test &lt;- y[-train_id] # Fit model on training data model &lt;- lm(y_train ~ x_train) # Predict on new data predictions &lt;- predict(model, newdata = data.frame(x_train = x_test)) head(predictions) ## 1 2 3 4 5 6 ## -1.18138102 2.94154666 0.04621488 0.80576347 0.12437508 -1.50903793 Here: The model is trained on one part of the data Predictions are made on new, unseen data 3.6.3 Evaluating Predictions Instead of p-values, we evaluate prediction error. mean((predictions - y_test)^2) ## [1] 0.5508944 3.6.4 Types of Machine Learning Tasks Most machine learning problems fall into two broad categories: regression and classification. 3.6.5 Regression Tasks Regression is used when the outcome variable is continuous. Examples: Predicting blood pressure Predicting gene expression levels Predicting healthcare costs Typical evaluation metrics for regression include: Mean Squared Error (MSE) ‚Äì average squared prediction error Root Mean Squared Error (RMSE) ‚Äì error on the original scale Mean Absolute Error (MAE) ‚Äì average absolute difference R-squared ‚Äì proportion of variance explained In this course, we have seen regression using linear models. 3.6.6 Classification Tasks Classification is used when the outcome variable is categorical. Examples: - Disease vs healthy - Treatment responder vs non-responder - Tumor type classification Common evaluation metrics for classification include: Accuracy ‚Äì proportion of correct predictions Sensitivity (Recall) ‚Äì ability to detect positive cases Specificity ‚Äì ability to detect negative cases Precision ‚Äì proportion of true positives among predicted positives The choice of metric depends on the problem context, especially in biomedical applications. 3.6.7 Advanced Machine Learning Algorithms (Overview) Beyond linear models, many advanced algorithms are commonly used in practice. Examples include: Logistic regression ‚Äì classification using probabilistic models Decision trees ‚Äì rule-based models Random forests ‚Äì ensembles of decision trees Support vector machines (SVMs) ‚Äì margin-based classifiers Neural networks ‚Äì layered models for complex patterns These methods are powerful, but require: Larger datasets Careful tuning Proper validation strategies üí° Note: Exploring these algorithms is beyond the scope of this course and typically covered in dedicated machine learning classes. For R, you can explore packages like caret and tidymodels specifically for ML tasks. 3.7 Hands-on Exercises 3.7.1 Exercise 1 Calculate descriptive statistics for Petal.Width grouped by species. 3.7.2 Exercise 2 Perform a t-test comparing Petal.Length between: setosa &amp; virginica 3.7.3 Exercise 3 Fit a linear model predicting Petal.Width from Petal.Length. 3.7.4 Exercise 4 (Challenge) Create a boxplot of Petal.Length by species and interpret the differences. "],["day-4-genomic-data-exploration-using-r---1.html", "4 Day-4 : Genomic Data Exploration Using R - 1 4.1 Learning Objectives 4.2 What Is Genomic Data? 4.3 What Is Bioconductor? 4.4 Installing Bioconductor", " 4 Day-4 : Genomic Data Exploration Using R - 1 4.1 Learning Objectives By the end of this day, students will be able to: Understand common genomic data types Learn what Bioconductor is and why it is used Work with expression data in R Use Bioconductor data structures Perform basic exploratory analysis on genomic datasets 4.2 What Is Genomic Data? Genomic data refers to information derived from DNA, RNA, or related molecules. Common genomic data types include: Gene expression data (RNA-seq, microarrays) Genomic coordinates (BED, GFF, GRanges) Variant data (VCF) Annotation data (gene names, pathways) In this course, we focus on gene expression data. 4.3 What Is Bioconductor? Bioconductor is a collection of R packages designed for: Genomic data analysis Biological annotation Reproducible research Key features: Standardized data structures Well-documented packages Strong integration with R statistics Bioconductor complements CRAN. 4.4 Installing Bioconductor Install Bioconductor (only once): # install.packages(&quot;BiocManager&quot;) [unhash it for first run] # BiocManager::install() [unhash it for first run] Install required packages: # BiocManager::install(c(&quot;SummarizedExperiment&quot;, &quot;airway&quot;, &quot;Biobase&quot;)) [unhash it for first run] Loading Required Libraries library(SummarizedExperiment) ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ## ## Attaching package: &#39;matrixStats&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## count ## ## Attaching package: &#39;MatrixGenerics&#39; ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ## colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ## colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ## colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ## colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ## colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ## colWeightedMeans, colWeightedMedians, colWeightedSds, ## colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ## rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ## rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ## rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ## rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ## rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ## rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ## rowWeightedSds, rowWeightedVars ## Loading required package: GenomicRanges ## Loading required package: stats4 ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following object is masked from &#39;package:lubridate&#39;: ## ## as.difftime ## The following object is masked from &#39;package:dplyr&#39;: ## ## explain ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Loading required package: S4Vectors ## ## Attaching package: &#39;S4Vectors&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## second, second&lt;- ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, rename ## The following object is masked from &#39;package:tidyr&#39;: ## ## expand ## The following object is masked from &#39;package:utils&#39;: ## ## findMatches ## The following objects are masked from &#39;package:base&#39;: ## ## expand.grid, I, unname ## Loading required package: IRanges ## ## Attaching package: &#39;IRanges&#39; ## The following object is masked from &#39;package:lubridate&#39;: ## ## %within% ## The following objects are masked from &#39;package:dplyr&#39;: ## ## collapse, desc, slice ## The following object is masked from &#39;package:purrr&#39;: ## ## reduce ## Loading required package: Seqinfo ## Loading required package: Biobase ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## ## Attaching package: &#39;Biobase&#39; ## The following object is masked from &#39;package:MatrixGenerics&#39;: ## ## rowMedians ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## anyMissing, rowMedians library(airway) library(Biobase) library(dplyr) library(ggplot2) library(DESeq2) Example Dataset: airway The airway dataset contains RNA-seq gene expression data from an experiment studying the effect of dexamethasone on human airway smooth muscle cells. What Kind of Data Is This? The airway dataset contains raw RNA-seq count data. Each value represents the number of sequencing reads mapped to a gene Values are integers Data is not normalized Data is not log-transformed Load the dataset: data(airway) airway ## class: RangedSummarizedExperiment ## dim: 63677 8 ## metadata(1): &#39;&#39; ## assays(1): counts ## rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492 ## ENSG00000273493 ## rowData names(10): gene_id gene_name ... seq_coord_system symbol ## colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521 ## colData names(9): SampleName cell ... Sample BioSample Understanding SummarizedExperiment SummarizedExperiment is a core Bioconductor data structure. It contains: assay data ‚Äì expression matrix rowData ‚Äì gene-level information colData ‚Äì sample-level metadata Exploring the Expression Data Assay Data (Counts Matrix) assay(airway)[1:5, 1:5] ## SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 ## ENSG00000000003 679 448 873 408 1138 ## ENSG00000000005 0 0 0 0 0 ## ENSG00000000419 467 515 621 365 587 ## ENSG00000000457 260 211 263 164 245 ## ENSG00000000460 60 55 40 35 78 Dimensions: dim(assay(airway)) ## [1] 63677 8 Sample Metadata (colData) colData(airway) ## DataFrame with 8 rows and 9 columns ## SampleName cell dex albut Run avgLength ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; ## SRR1039508 GSM1275862 N61311 untrt untrt SRR1039508 126 ## SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 ## SRR1039512 GSM1275866 N052611 untrt untrt SRR1039512 126 ## SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 ## SRR1039516 GSM1275870 N080611 untrt untrt SRR1039516 120 ## SRR1039517 GSM1275871 N080611 trt untrt SRR1039517 126 ## SRR1039520 GSM1275874 N061011 untrt untrt SRR1039520 101 ## SRR1039521 GSM1275875 N061011 trt untrt SRR1039521 98 ## Experiment Sample BioSample ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## SRR1039508 SRX384345 SRS508568 SAMN02422669 ## SRR1039509 SRX384346 SRS508567 SAMN02422675 ## SRR1039512 SRX384349 SRS508571 SAMN02422678 ## SRR1039513 SRX384350 SRS508572 SAMN02422670 ## SRR1039516 SRX384353 SRS508575 SAMN02422682 ## SRR1039517 SRX384354 SRS508576 SAMN02422673 ## SRR1039520 SRX384357 SRS508579 SAMN02422683 ## SRR1039521 SRX384358 SRS508580 SAMN02422677 Convert to data frame: sample_info &lt;- as.data.frame(colData(airway)) head(sample_info) ## SampleName cell dex albut Run avgLength Experiment ## SRR1039508 GSM1275862 N61311 untrt untrt SRR1039508 126 SRX384345 ## SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 SRX384346 ## SRR1039512 GSM1275866 N052611 untrt untrt SRR1039512 126 SRX384349 ## SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 SRX384350 ## SRR1039516 GSM1275870 N080611 untrt untrt SRR1039516 120 SRX384353 ## SRR1039517 GSM1275871 N080611 trt untrt SRR1039517 126 SRX384354 ## Sample BioSample ## SRR1039508 SRS508568 SAMN02422669 ## SRR1039509 SRS508567 SAMN02422675 ## SRR1039512 SRS508571 SAMN02422678 ## SRR1039513 SRS508572 SAMN02422670 ## SRR1039516 SRS508575 SAMN02422682 ## SRR1039517 SRS508576 SAMN02422673 Gene Metadata (rowData) rowData(airway) ## DataFrame with 63677 rows and 10 columns ## gene_id gene_name entrezid gene_biotype ## &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;character&gt; ## ENSG00000000003 ENSG00000000003 TSPAN6 NA protein_coding ## ENSG00000000005 ENSG00000000005 TNMD NA protein_coding ## ENSG00000000419 ENSG00000000419 DPM1 NA protein_coding ## ENSG00000000457 ENSG00000000457 SCYL3 NA protein_coding ## ENSG00000000460 ENSG00000000460 C1orf112 NA protein_coding ## ... ... ... ... ... ## ENSG00000273489 ENSG00000273489 RP11-180C16.1 NA antisense ## ENSG00000273490 ENSG00000273490 TSEN34 NA protein_coding ## ENSG00000273491 ENSG00000273491 RP11-138A9.2 NA lincRNA ## ENSG00000273492 ENSG00000273492 AP000230.1 NA lincRNA ## ENSG00000273493 ENSG00000273493 RP11-80H18.4 NA lincRNA ## gene_seq_start gene_seq_end seq_name seq_strand ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; ## ENSG00000000003 99883667 99894988 X -1 ## ENSG00000000005 99839799 99854882 X 1 ## ENSG00000000419 49551404 49575092 20 -1 ## ENSG00000000457 169818772 169863408 1 -1 ## ENSG00000000460 169631245 169823221 1 1 ## ... ... ... ... ... ## ENSG00000273489 131178723 131182453 7 -1 ## ENSG00000273490 54693789 54697585 HSCHR19LRC_LRC_J_CTG1 1 ## ENSG00000273491 130600118 130603315 HG1308_PATCH 1 ## ENSG00000273492 27543189 27589700 21 1 ## ENSG00000273493 58315692 58315845 3 1 ## seq_coord_system symbol ## &lt;integer&gt; &lt;character&gt; ## ENSG00000000003 NA TSPAN6 ## ENSG00000000005 NA TNMD ## ENSG00000000419 NA DPM1 ## ENSG00000000457 NA SCYL3 ## ENSG00000000460 NA C1orf112 ## ... ... ... ## ENSG00000273489 NA RP11-180C16.1 ## ENSG00000273490 NA TSEN34 ## ENSG00000273491 NA RP11-138A9.2 ## ENSG00000273492 NA AP000230.1 ## ENSG00000273493 NA RP11-80H18.4 Basic Quality Checks Library Sizes library_sizes &lt;- colSums(assay(airway)) library_sizes ## SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 ## 20637971 18809481 25348649 15163415 24448408 30818215 19126151 ## SRR1039521 ## 21164133 Visualize library sizes: ggplot(data.frame(library_sizes), aes(x = library_sizes)) + geom_histogram(bins = 10, fill = &quot;steelblue&quot;) + labs( title = &quot;Library Size Distribution&quot;, x = &quot;Total Read Counts&quot;, y = &quot;Number of Samples&quot; ) counts &lt;- assay(airway) hist(counts[, 1], breaks = 50, main = &quot;Distribution of Raw Counts (Sample 1)&quot;, xlab = &quot;Read Counts&quot;) 4.4.1 Log Transformation for Exploration Raw counts are highly skewed. For visualization only, we use a log transformation: log_counts &lt;- log2(counts + 1) hist(log_counts[, 1], breaks = 50, main = &quot;Log-transformed Counts (Sample 1)&quot;, xlab = &quot;log2(count + 1)&quot;) group &lt;- colData(airway)$dex group ## [1] untrt trt untrt trt untrt trt untrt trt ## Levels: trt untrt boxplot( log_counts, col = ifelse(group == &quot;trt&quot;, &quot;tomato&quot;, &quot;lightblue&quot;), las = 2, main = &quot;Log-transformed Expression Values&quot; ) 4.4.2 Differential Expression Analysis (Conceptual) We now demonstrate how genomic analyses are typically performed using a specialized package. dds &lt;- DESeqDataSet( airway, design = ~ dex ) dds &lt;- DESeq(dds) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing res &lt;- results(dds) head(res) ## log2 fold change (MLE): dex untrt vs trt ## Wald test p-value: dex untrt vs trt ## DataFrame with 6 rows and 6 columns ## baseMean log2FoldChange lfcSE stat pvalue ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## ENSG00000000003 708.602170 0.3788470 0.173141 2.188082 0.0286636 ## ENSG00000000005 0.000000 NA NA NA NA ## ENSG00000000419 520.297901 -0.2037604 0.100599 -2.025478 0.0428183 ## ENSG00000000457 237.163037 -0.0340428 0.126279 -0.269584 0.7874802 ## ENSG00000000460 57.932633 0.1171786 0.301237 0.388992 0.6972820 ## ENSG00000000938 0.318098 1.7245505 3.493633 0.493627 0.6215698 ## padj ## &lt;numeric&gt; ## ENSG00000000003 0.139308 ## ENSG00000000005 NA ## ENSG00000000419 0.183359 ## ENSG00000000457 0.930572 ## ENSG00000000460 0.895441 ## ENSG00000000938 NA res_df &lt;- as.data.frame(res) res_df$gene &lt;- rownames(res_df) sig_genes &lt;- res_df %&gt;% filter(padj &lt; 0.05, abs(log2FoldChange) &gt; 1) nrow(sig_genes) ## [1] 877 head(sig_genes) ## baseMean log2FoldChange lfcSE stat pvalue ## ENSG00000003402 2546.61420 -1.183425 0.1635592 -7.235455 4.639712e-13 ## ENSG00000004799 914.37901 -2.544032 0.9011874 -2.822977 4.757993e-03 ## ENSG00000004846 17.99917 1.881406 0.6992853 2.690470 7.135153e-03 ## ENSG00000005471 33.66399 1.218750 0.4343571 2.805871 5.018075e-03 ## ENSG00000006788 10.25338 -3.169070 1.0663557 -2.971869 2.959927e-03 ## ENSG00000008256 3716.57738 -1.204606 0.2043656 -5.894367 3.761198e-09 ## padj gene ## ENSG00000003402 5.563164e-11 ENSG00000003402 ## ENSG00000004799 3.621101e-02 ENSG00000004799 ## ENSG00000004846 4.938802e-02 ENSG00000004846 ## ENSG00000005471 3.772691e-02 ENSG00000005471 ## ENSG00000006788 2.511883e-02 ENSG00000006788 ## ENSG00000008256 1.925671e-07 ENSG00000008256 4.4.3 Volcano Plot A volcano plot shows both effect size and significance. ggplot(res_df, aes(x = log2FoldChange, y = -log10(pvalue))) + geom_point(alpha = 0.4) + geom_vline(xintercept = c(-1, 1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;) + labs( title = &quot;Volcano Plot&quot;, x = &quot;Log2 Fold Change&quot;, y = &quot;-log10(p-value)&quot; ) ## Warning: Removed 30259 rows containing missing values or values outside ## the scale range (`geom_point()`). we can add colors based on up-regulation and down-regulation. res_df &lt;- res_df %&gt;% mutate( regulation = case_when( padj &lt; 0.05 &amp; log2FoldChange &gt; 1 ~ &quot;Up-regulated&quot;, padj &lt; 0.05 &amp; log2FoldChange &lt; -1 ~ &quot;Down-regulated&quot;, TRUE ~ &quot;Not significant&quot; ) ) ggplot(res_df, aes(x = log2FoldChange, y = -log10(pvalue), color = regulation)) + geom_point(alpha = 0.6, size = 0.25) + geom_vline(xintercept = c(-1, 1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;) + scale_color_manual( values = c( &quot;Up-regulated&quot; = &quot;red&quot;, &quot;Down-regulated&quot; = &quot;blue&quot;, &quot;Not significant&quot; = &quot;grey&quot; ) ) + labs( title = &quot;Volcano Plot of Differential Gene Expression&quot;, x = &quot;Log2 Fold Change&quot;, y = &quot;-log10(p-value)&quot;, color = &quot;Gene Regulation&quot; ) + theme_minimal() ## Warning: Removed 30259 rows containing missing values or values outside ## the scale range (`geom_point()`). adding the labels for top most significant genes. library(ggrepel) top_genes &lt;- res_df %&gt;% filter(regulation != &quot;Not significant&quot;) %&gt;% arrange(padj) %&gt;% head(10) ggplot(res_df, aes(log2FoldChange, -log10(pvalue), color = regulation)) + geom_point(alpha = 0.6, size = 0.5) + geom_text_repel( data = top_genes, aes(label = gene), size = 3 ) + geom_vline(xintercept = c(-1, 1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;) + scale_color_manual( values = c(&quot;Up-regulated&quot; = &quot;red&quot;, &quot;Down-regulated&quot; = &quot;blue&quot;, &quot;Not significant&quot; = &quot;grey&quot;) ) + theme_minimal() ## Warning: Removed 30259 rows containing missing values or values outside ## the scale range (`geom_point()`). "],["day-5-genomic-data-exploration-using-r---2.html", "5 Day-5 : Genomic Data Exploration Using R - 2", " 5 Day-5 : Genomic Data Exploration Using R - 2 proteins &lt;- data.frame(name = c( &quot;HBA&quot;, &quot;HBB&quot;, &quot;HBD&quot;, &quot;HBG1&quot;, &quot;HBG2&quot;, &quot;HBE1&quot;, &quot;MB&quot;, &quot;NGB&quot;, &quot;CYGB&quot; ),uniprot_id = c( &quot;P69905&quot;, &quot;P68871&quot;, &quot;P02042&quot;, &quot;P69891&quot;, &quot;P69892&quot;, &quot;P02100&quot;, &quot;P02144&quot;, &quot;Q9NPG2&quot;, &quot;Q8WWI4&quot; ), stringsAsFactors = FALSE ) proteins ## name uniprot_id ## 1 HBA P69905 ## 2 HBB P68871 ## 3 HBD P02042 ## 4 HBG1 P69891 ## 5 HBG2 P69892 ## 6 HBE1 P02100 ## 7 MB P02144 ## 8 NGB Q9NPG2 ## 9 CYGB Q8WWI4 dir.create(&quot;fasta_files&quot;, showWarnings = FALSE) for (i in seq_len(nrow(proteins))) { url &lt;- paste0( &quot;https://rest.uniprot.org/uniprotkb/&quot;, proteins$uniprot_id[i], &quot;.fasta&quot; ) dest &lt;- file.path( &quot;fasta_files&quot;, paste0(proteins$name[i], &quot;.fasta&quot;) ) download.file(url, dest) } read_fasta &lt;- function(file) { lines &lt;- readLines(file) sequence &lt;- paste(lines[-1], collapse = &quot;&quot;) sequence &lt;- gsub(&quot;[^ACDEFGHIKLMNPQRSTVWY]&quot;, &quot;&quot;, sequence) sequence } fasta_files &lt;- list.files(&quot;fasta_files&quot;, full.names = TRUE) sequences &lt;- sapply(fasta_files, read_fasta) names(sequences) &lt;- proteins$name sequences ## HBA ## &quot;MAPVYEGMASHVQVFSPHTLQSSAFCSVKKLKIEPSSNWDMTGYGSHSKVYSQSKNIPLSQPATTTVSTSLPVPNPSLPYEQTIVFPGSTGHIVVTSASSTSVTGQVLGGPHNLMRRSTVSLLDTYQKCGLKRKSEEIENTSSVQIIEEHPPMIQNNASGATVATATTSTATSKNSGSNSEGDYQLVQHEVLCSMTNTYEVLEFLGRGTFGQVVKCWKRGTNEIVAIKILKNHPSYARQGQIEVSILARLSTESADDYNFVRAYECFQHKNHTCLVFEMLEQNLYDFLKQNKFSPLPLKYIRPVLQQVATALMKLKSLGLIHADLKPENIMLVDPSRQPYRVKVIDFGSASHVSKAVCSTYLQSRYYRAPEIILGLPFCEAIDMWSLGCVIAELFLGWPLYPGASEYDQIRYISQTQGLPAEYLLSAGTKTTRFFNRDTDSPYPLWRLKTPDDHEAETGIKSKEARKYIFNCLDDMAQVNMTTDLEGSDMLVEKADRREFIDLLKKMLTIDADKRITPIETLNHPFVTMTHLLDFPHSTHVKSCFQNMEICKRRVNMYDTVNQSKTPFITHVAPSTSTNLTMTFNNQLTTVHNQAPSSTSATISLANPEVSILNYPSTLYQPSAASMAAVAQRSMPLQTGTAQICARPDPFQQALIVCPPGFQGLQASPSKHAGYSVRMENAVPIVTQAPGAQPLQIQPGLLAQQAWPSGTQQILLPPAWQQLTGVATHTSVQHATVIPETMAGTQQLADWRNTHAHGSHYNPIMQQPALLTGHVTLPAAQPLNVGVAHVMRQQPTSTTSSRKSKQHQSSVRNVSTCEVSSSQAISSPQRSKRVKENTPPRCAMVHSSPACSTSVTCGWGDVASSTTRERQRQTIVIPDTPSPTVSVITISSDTDEEEEQKHAPTSTVSKQRKNVISCVTVHDSPYSDSSSNTSPYSVQQRAGHNNANAFDTKGSLENHCTGNPRTIIVPPLKTQASEVLVECDSLVPVNTSHHSSSYKSKSSSNVTSTSGHSSGSSSGAITYRQQRPGPHFQQQQPLNLSQAQQHITTDRTGSHRRQQAYITPTMAQAPYSFPHNSPSHGTVHPHLAAAAAAAHLPTQPHLYTYTAPAALGSTGTVAHLVASQGSARHTVQHTAYPASIVHQVPVSMGPRVLPSPTIHPSQYPAQFAHQTYISASPASTVYTGYPLSPAKVNQYPYI&quot; ## HBB ## &quot;MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHGKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTPAVHASLDKFLASVSTVLTSKYR&quot; ## HBD ## &quot;MVHLTPEEKSAVTALWGKVNVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPKVKAHGKKVLGAFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHHFGKEFTPPVQAAYQKVVAGVANALAHKYH&quot; ## HBG1 ## &quot;MVHLTPEEKTAVNALWGKVNVDAVGGEALGRLLVVYPWTQRFFESFGDLSSPDAVMGNPKVKAHGKKVLGAFSDGLAHLDNLKGTFSQLSELHCDKLHVDPENFRLLGNVLVCVLARNFGKEFTPQMQAAYQKVVAGVANALAHKYH&quot; ## HBG2 ## &quot;MVHFTAEEKAAVTSLWSKMNVEEAGGEALGRLLVVYPWTQRFFDSFGNLSSPSAILGNPKVKAHGKKVLTSFGDAIKNMDNLKPAFAKLSELHCDKLHVDPENFKLLGNVMVIILATHFGKEFTPEVQAAWQKLVSAVAIALAHKYH&quot; ## HBE1 ## &quot;MGHFTEEDKATITSLWGKVNVEDAGGETLGRLLVVYPWTQRFFDSFGNLSSASAIMGNPKVKAHGKKVLTSLGDATKHLDDLKGTFAQLSELHCDKLHVDPENFKLLGNVLVTVLAIHFGKEFTPEVQASWQKMVTAVASALSSRYH&quot; ## MB ## &quot;MGHFTEEDKATITSLWGKVNVEDAGGETLGRLLVVYPWTQRFFDSFGNLSSASAIMGNPKVKAHGKKVLTSLGDAIKHLDDLKGTFAQLSELHCDKLHVDPENFKLLGNVLVTVLAIHFGKEFTPEVQASWQKMVTGVASALSSRYH&quot; ## NGB ## &quot;MGLSDGEWQLVLNVWGKVEADIPGHGQEVLIRLFKGHPETLEKFDKFKHLKSEDEMKASEDLKKHGATVLTALGGILKKKGHHEAEIKPLAQSHATKHKIPVKYLEFISECIIQVLQSKHPGDFGADAQGAMNKALELFRKDMASNYKELGFQG&quot; ## CYGB ## &quot;MERPEPELIRQSWRAVSRSPLEHGTVLFARLFALEPDLLPLFQYNCRQFSSPEDCLSSPEFLDHIRKVMLVIDAAVTNVEDLSSLEEYLASLGRKHRAVGVKLSSFSTVGESLLYMLEKCLGPAFTPATRAAWSQLYGAVVQAMSRGWDGE&quot; protein_lengths &lt;- nchar(sequences) length_df &lt;- data.frame( Protein = names(protein_lengths), Length = as.numeric(protein_lengths) ) length_df ## Protein Length ## 1 HBA 1198 ## 2 HBB 142 ## 3 HBD 147 ## 4 HBG1 147 ## 5 HBG2 147 ## 6 HBE1 147 ## 7 MB 147 ## 8 NGB 154 ## 9 CYGB 151 aa_composition &lt;- lapply(sequences, function(seq) { table(strsplit(seq, &quot;&quot;)[[1]]) }) aa_composition ## $HBA ## ## A C D E F G H I K L M N P Q R S T V W Y ## 94 21 36 45 28 55 51 55 47 83 27 48 92 86 46 138 111 84 9 42 ## ## $HBB ## ## A C D E F G H K L M N P Q R S T V W Y ## 21 1 8 4 7 7 10 11 18 3 4 7 1 3 11 9 13 1 3 ## ## $HBD ## ## A C D E F G H K L M N P Q R S T V W Y ## 15 2 7 8 8 13 9 11 18 2 6 7 3 3 5 7 18 2 3 ## ## $HBG1 ## ## A C D E F G H K L M N P Q R S T V W Y ## 15 2 7 7 8 13 7 11 18 3 8 6 5 4 6 5 17 2 3 ## ## $HBG2 ## ## A C D E F G H I K L M N P Q R S T V W Y ## 17 1 5 9 9 9 7 5 14 16 4 7 6 3 2 9 6 13 3 2 ## ## $HBE1 ## ## A C D E F G H I K L M N P Q R S T V W Y ## 12 1 8 8 8 12 7 3 12 17 3 5 4 4 3 11 11 13 3 2 ## ## $MB ## ## A C D E F G H I K L M N P Q R S T V W Y ## 11 1 8 8 8 13 7 4 12 17 3 5 4 4 3 11 10 13 3 2 ## ## $NGB ## ## A C D E F G H I K L M N P Q R S T V W Y ## 12 1 8 14 7 15 9 8 20 17 4 3 5 7 2 7 4 7 2 2 ## ## $CYGB ## ## A C D E F G H I K L M N P Q R S T V W Y ## 13 3 6 13 7 8 3 3 4 21 4 2 9 5 11 16 5 11 3 4 hydrophobic &lt;- c(&quot;A&quot;, &quot;V&quot;, &quot;I&quot;, &quot;L&quot;, &quot;M&quot;, &quot;F&quot;, &quot;W&quot;, &quot;Y&quot;) hydrophobic_fraction &lt;- sapply(sequences, function(seq) { aa &lt;- strsplit(seq, &quot;&quot;)[[1]] mean(aa %in% hydrophobic) }) hydrophobic_df &lt;- data.frame( Protein = names(hydrophobic_fraction), HydrophobicFraction = hydrophobic_fraction ) hydrophobic_df ## Protein HydrophobicFraction ## HBA HBA 0.3522538 ## HBB HBB 0.4647887 ## HBD HBD 0.4489796 ## HBG1 HBG1 0.4489796 ## HBG2 HBG2 0.4693878 ## HBE1 HBE1 0.4149660 ## MB MB 0.4149660 ## NGB NGB 0.3831169 ## CYGB CYGB 0.4370861 ggplot(hydrophobic_df, aes(x = Protein, y = HydrophobicFraction)) + geom_col() + labs( title = &quot;Hydrophobic Amino Acid Fraction&quot;, y = &quot;Fraction&quot;, x = &quot;Protein&quot; ) motif &lt;- &quot;AA&quot; motif_counts &lt;- sapply(sequences, function(seq) { length(gregexpr(motif, seq)[[1]][gregexpr(motif, seq)[[1]] &gt; 0]) }) motif_df &lt;- data.frame( Protein = names(motif_counts), HG_Count = motif_counts ) motif_df ## Protein HG_Count ## HBA HBA 7 ## HBB HBB 2 ## HBD HBD 1 ## HBG1 HBG1 1 ## HBG2 HBG2 2 ## HBE1 HBE1 0 ## MB MB 0 ## NGB NGB 0 ## CYGB CYGB 2 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
